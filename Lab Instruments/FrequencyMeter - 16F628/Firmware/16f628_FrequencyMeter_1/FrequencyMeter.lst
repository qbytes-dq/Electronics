MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  1


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00001 ;**************************************************************************
                      00002 ; FILE:      counter.asm                                                  *
                      00003 ; CONTENTS:  Simple low-cost digital frequency meter using a PIC 16F628   *
                      00004 ; AUTHOR:    Wolfgang Buescher, DL4YHF                                    *
                      00005 ;            (based on a work by James Hutchby, MadLab, 1996)             *
                      00006 ; REVISIONS: (latest entry first)                                         *
                      00007 ; 2009-08-27 - Added RS232 output option 1200 Bd by Jan Panteltje         *
                      00008 ; 2006-05-31 - Added the 'power-save' option which temporarily puts the   *
                      00009 ;              PIC to sleep (with only the watchdog-oscillator running)   *
                      00010 ; 2006-05-15 - New entry in the preconfigured frequency table for 4-MHz   *
                      00011 ;              IF filters (like "Miss Mosquita" [Moskita] by DK1HE)       *
                      00012 ; 2005-08-24 - Cured a bug in the COMMON ANODE decimal point setting .    *
                      00013 ;              (the "^0xFF" for the AND-mask was missing in macro 'conv') *
                      00014 ; 2005-03-21 - Added a few conditionals to use the same sourcecode        *
                      00015 ;              to drive a COMMON ANODE display ( DISPLAY_VARIANT_3 )      *
                      00016 ; 2004-03-14 - Fixed a range-switching bug around 8 MHz .                 *
                      00017 ;            - Support TWO different display variants now,                *
                      00018 ;              optimized for different board layouts, and different clock *
                      00019 ;              frequencies (4 MHz for variant 1,  20 MHz for variant 2).  *
                      00020 ; 2004-03-05 - Added the feature to add or subtract a frequency offset .  *
                      00021 ; 2004-02-18 - Migration to a PIC16F628 with 4 MHz crystal (el Cheapo)    *
                      00022 ;            - Changed the LED patterns '6' and '9' because they looked   *
                      00023 ;              like 'b' and 'q' in the old counter version .              *
                      00024 ;            - Added the auto-ranging feature                             *
                      00025 ;            - Stepped from 24-bit to 32-bit integer arithmetic, to be    *
                      00026 ;              able to count 50 MHz with 1-second gate time,              *
                      00027 ;              or (at least) adjust ANY result for the ANY prescaler      *
                      00028 ;              division ratio, which may give pretty large numbers .      *
                      00029 ;            - A PIC16F628 worked up to 63 MHz with this firmware .       *
                      00030 ;**************************************************************************
                      00031 
Warning[215]: Processor superseded by command line.  Verify processor symbol.
                      00032  list P=16F648a
                      00033 ; #include <p16F628.inc>        ; processor specific definitions
                      00034  #include <p16f648a.inc>        ; processor specific definitions
                      00001         LIST
                      00002 
                      00003 ;==========================================================================
                      00004 ;  MPASM PIC16F648A processor include
                      00005 ; 
                      00006 ;  (c) Copyright 1999-2013 Microchip Technology, All rights reserved
                      00007 ;==========================================================================
                      00008 
Message[301]: MESSAGE: (Processor-header file mismatch.  Verify selected processor.)
                      00384         LIST
                      00035 
                      00036 
                      00037 ; Uncomment this if you want RS232 output
                      00038 #define RS232_OUT
                      00039 
                      00040 ; Uncomment the next line if you want pin 8 of the PIC to directly drive a RS232 line (without MAX232 or
                             such). 
                      00041 #define NON_INVERTING_RS232_OUT
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  2


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00042 
                      00043 ; BAUD_DIVIDER set to 1 for 9600 Bd, 2 for 4800 Bd, 4 for 2400 Bd, 8 for 1200 Bd, 16 for 600 Bd, 32 for 
                            300 Bd, 64 for 150 Bd, and 128 for 75 Bd.
                      00044 ; Note: for 9600 Bd set BIT_DELAY to 27, or basically a bit lower then for the other baudrates, due to m
                            ore relative time spend in other instructions.
                      00045 #define BAUD_DIVIDER    d'8'            ; 1200 Baud     
                      00046 
                      00047 ; set baudrate, for small deviations of the internal oscillator this may need to be adapted.
                      00048 #define BIT_DELAY               d'165'          ; approx 165 for 1200 Bd        with 20 MHz clock
                      00049 
                      00050 ; for software RS232 out, NOT using UART
                      00051 #define RS232_PORT              PORTB           
                      00052 #define RS232_BIT               D'2'            ; RB2, pin 8
                      00053 
                      00054 
                      00055 ; print options, all field active looks like:
                      00056 ; 00000050  50 Hz  0.050 kHz
                      00057 ; 19999968  19,999,968 Hz  19.999 MHz
                      00058 ; Uncomment this if you want the first field printed.
                      00059 #define RS232_PRINT_FIELD_1
                      00060 ; Uncomment this if you want the secind field printed. 
                      00061 #define RS232_PRINT_FIELD_2
                      00062 ; Uncomment this if you want the third field printed.
                      00063 ;#define RS232_PRINT_FIELD_3
                      00064 ; Note: The first field is for parsing by user space programs. it is recommanded to always leave the fie
                            ld active.
                      00065 
                      00066 
                      00067 ; for unit printing
                      00068 #define KILOHERTZ_FLAG                          1
                      00069 #define NO_INPUT_FLAG                           2
                      00070 #define ZERO_SUPPRESSION_FLAG           4
                      00071 
                      00072 
                      00073 
                      00074 #define DISPLAY_VARIANT_2
                      00075 
                      00076 
                      00077  #define DEBUG 0         ; DEBUG=1 for simulation, DEBUG=0 for real hardware
                      00078 
                      00079 
                      00080 
                      00081 ; Selection of LED display control bits... since 2005, three different variants.
                      00082 ; Select ONE OF THESE in MPLAB under "Project".."Build Options".."Macro Definitions"!
                      00083 ;  DISP_VARIANT=1  :   first prototype, PIC on left side of display
                      00084 ;  DISP_VARIANT=2  :   second prototype, separated PIC and display board
                      00085 ;  DISP_VARIANT=3  :   similar as (2), but for COMMON CATHODE display
                      00086 ; Unfortunately it seems impossible to assign a NUMERIC VALUE to a macro 
                      00087 ;   in MPLAB (not in MPASM!) ....
                      00088 #ifdef DISPLAY_VARIANT_1
                      00089   #define DISP_VARIANT 1    ; very first (old) prototype by DL4YHF
                      00090   #define COMMON_ANODE   0
                      00091   #define COMMON_CATHODE 1
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  3


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00092 #else
                      00093 #ifdef DISPLAY_VARIANT_2
                      00094   #define DISP_VARIANT 2    ; 5 digits, new layout, COMMON CATHODE
                      00095   #define COMMON_ANODE   0
                      00096   #define COMMON_CATHODE 1
                      00097 #else
                      00098 #ifdef DISPLAY_VARIANT_3    ; added 2005-03-21 :
                      00099   #define DISP_VARIANT 3    ; similar as (2), but for COMMON ANODE display
                      00100   #define COMMON_ANODE   1
                      00101   #define COMMON_CATHODE 0
                      00102 #else
                      00103   #define DISP_VARIANT 4
                      00104   #define COMMON_ANODE   0
                      00105   #define COMMON_CATHODE 1
                      00106 ;  "Error, Must define DISPLAY_VARIANT_1, .._2, or .._3 under project options"
                      00107   ; With MPLAB: Project..Build Options..Project..MPASM..Macro Definitions..Add
                      00108 #endif
                      00109 #endif
                      00110 #endif
                      00111 
                      00112 
                      00113 
                      00114 ;**************************************************************************
                      00115 ;                                                                         *
                      00116 ; Summary                                                                 *
                      00117 ;                                                                         *
                      00118 ;**************************************************************************
                      00119 
                      00120 ; The software functions as a frequency meter with an input signal
                      00121 ; range of 1 Hz to ~ 50 MHz and with an accuracy of +/- 1Hz
                      00122 ; if the oscillator crystal is properly trimmed .
                      00123 
                      00124 ; Signal pulses are counted over a fixed time interval of 1/4 second to
                      00125 ; 1 second (gate time). High frequency pulses are counted over 1/4 s 
                      00126 ; to make the meter more responsive with no loss of displayed accuracy.
                      00127 
                      00128 ; Pulses are counted using Timer 0 of the PIC,
                      00129 ; which is set to increment on rising edges on the TMR0 pin. The 8-bit
                      00130 ; hardware register is extended by software into a 32-bit pulse counter.
                      00131 ; If timer 0 rolls over (msb 1 -> 0) between successive polls then the
                      00132 ; high two bytes of the pulse counter are incremented.
                      00133 
                      00134 ; Timer 0 is unable to count more than one pulse per instruction cycle
                      00135 ; (per 4 clock cycles) so the prescaler is used at frequencies above
                      00136 ; 1MHz (4MHz clock / 4) and also to ensure that pulses are not lost
                      00137 ; between polls of timer 0 (which would happen if more than 128 pulses were
                      00138 ; received). Fortunately the prescaler is an asynchronous counter
                      00139 ; which works up to a few ten MHz (sometimes as far as 60 MHz) .
                      00140 
                      00141 ; Timing is based on a software loop of known execution period . The loop
                      00142 ; time is 50 or 20 us which gives integer counts to time 1 s  and 1/4 s .
                      00143 ; During this timing loop, the multiplexed LED display is updated .
                      00144 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  4


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00145 ; The frequency in binary is converted to decimal using a powers-of-ten
                      00146 ; lookup table. The binary powers of ten are repeatedly subtracted from
                      00147 ; the frequency to determine the individual decimal digits. The decimal
                      00148 ; digits are stored at the 8 bytes at 'digits'. Leading zeroes are then
                      00149 ; suppressed and the 4 (or 5) significant digits are converted to LED data
                      00150 ; for the 7-segment displays using a lookup table.
                      00151 
                      00152 ; The signal frequency is displayed on four (or five) 7-segment displays. 
                      00153 ; The displays are multiplexed which means that only one display is enabled 
                      00154 ; at any one time. The variable 'disp_index' contains the index of the currently
                      00155 ; enabled display. Each display is enabled in turn at a sufficient frequency
                      00156 ; that no flicker is discernable. A prescaler ('disp_timer') is used
                      00157 ; to set the multiplexing frequency to a few hundred Hz.
                      00158 
                      00159 ; The display shows the signal frequency in KHz or MHz, according to the
                      00160 ; following table:
                      00161 
                      00162 ; --------------------------
                      00163 ; | Frequency | Display    |
                      00164 ; --------------------------
                      00165 ; | < 1Hz     |       0    |
                      00166 ; | 1Hz       |   0.001[0] |  Note: kHz-dot is flashing (blinking)
                      00167 ; | 10Hz      |   0.010[0] |
                      00168 ; | 100Hz     |   0.100[0] |
                      00169 ; | 1.000KHz  |   1.000[0] |
                      00170 ; | 10.00KHz  |   10.00[0] |
                      00171 ; | 100.0KHz  |   100.0[0] |
                      00172 ; | 1.000MHz  |   1.000[0] |  Note: MHz-dot is steady (not blinking)
                      00173 ; | 10.00MHz  |   10.00[0] |
                      00174 ; --------------------------
                      00175 
                      00176 ; If there is no signal at all, a single zero is displayed in the 4th(!) digit.
                      00177 ; Overflows are not displayed because they cannot be detected !
                      00178 
                      00179 
                      00180 ;**************************************************************************
                      00181 ;                                                                         *
                      00182 ; PIC config definitions                                                  *
                      00183 ;                                                                         *
                      00184 ;**************************************************************************
                      00185 
                      00186 
                      00187 ; '__CONFIG' directive is used to embed configuration data within .asm file.
                      00188 ; The lables following the directive are located in the respective .inc file.
                      00189 ; See respective data sheet for additional information on configuration word.
                      00190 ; Since 2006-05-28, the watchdog must be ENABLE in the config word
                      00191 ;       because of its wakeup-from-sleep function (see 'Sleep100ms') .
                      00192 ; EX(16F84:)     __CONFIG   _CP_OFF & _WDT_ON & _PWRTE_ON & _RC_OSC
                      00193 #if (DISP_VARIANT==1)  ; display variant 1 : clocked with 4 MHz (low power, "XT" )
                      00194    __CONFIG   _CP_OFF & _WDT_ON & _PWRTE_ON & _XT_OSC & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF
                      00195 #else                  ; display variants 2+3 : clocked with 20 MHz (needs "HS" oscillator)
2007   3F06           00196    __CONFIG   _CP_OFF & _WDT_ON & _PWRTE_ON & _HS_OSC & _LVP_OFF & _BODEN_OFF & _MCLRE_OFF
                      00197 #endif
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  5


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00198 
                      00199 
                      00200 
                      00201 ; '__IDLOCS' directive may be used to set the 4 * 4(?!?) ID Location Bits .
                      00202 ; These shall be placed in the HEX file at addresses 0x2000...0x2003 .
2000   0001 0002 0003 00203    __IDLOCS H'1234'
       0004 
                      00204 
                      00205 
                      00206 ; (definitions of "file" registers removed.  They are defined in a header file!)
                      00207 
                      00208 
                      00209 
                      00210 ;**************************************************************************
                      00211 ;                                                                         *
                      00212 ; Port assignments                                                        *
                      00213 ;                                                                         *
                      00214 ;**************************************************************************
                      00215 
  00000000            00216 PORT_A_IO      equ  b'0000'        ; port A I/O mode (all output)
  00000000            00217 PORT_B_IO      equ  b'00000000'    ; port B I/O mode (all output)
                      00218 
  00000006            00219 LEDS_PORT      equ  PORTB          ; 7-segment LEDs port
                      00220 
  00000005            00221 ENABLE_PORT    equ  PORTA          ; display enable port
                      00222   ; Bitmasks to control the digit outputs have been moved to enable_table .
                      00223   ; YHF: Note that 'display #0' is the MOST SIGNIFICANT digit !
                      00224 
                      00225 
                      00226 #define IOP_PROG_MODE  PORTA,5   ; digital input signal, LOW enters programming mode
                      00227   
                      00228 
                      00229 
                      00230 
                      00231 ;**************************************************************************
                      00232 ;                                                                         *
                      00233 ; Constants and timings                                                   *
                      00234 ;                                                                         *
                      00235 ;**************************************************************************
                      00236 
                      00237 ; processor clock frequency in Hz (4MHz)
                      00238 #if (DISP_VARIANT==1)  ; display variant 1 : clocked with 4 MHz (low power consumption)
                      00239 CLOCK     equ  .4000000
                      00240 #else                  ; display variants 2+3 : clocked with 20 MHz (higher resolution)
  01312D00            00241 CLOCK     equ  .20000000
                      00242 #endif
                      00243 
                      00244 ; microseconds per timing loop
                      00245 #if (DISP_VARIANT==1)  ; display variant 1 : clocked with 4 MHz
                      00246   ; 20 microseconds is impossible with 4-MHz-Crystal, so use 50 us instead ! 
                      00247   ; Make sure all gate times can be divided by this interval without remainder :
                      00248   ; 1   second / 50 us = 20000  (ok)
                      00249   ; 1/4 second / 50 us =  5000  (ok)
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  6


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00250   ; 1/8 second / 50 us =  2500  (ok)
                      00251 TIME      equ  .50
                      00252 #else                  ; display variants 2+3 : clocked with 20 MHz
                      00253   ; 20 microseconds is impossible with 4-MHz-Crystal, so use 50 us instead ! 
                      00254   ; Make sure all gate times can be divided by this interval without remainder :
                      00255   ; 1   second / 20 us = 50000  (ok)
                      00256   ; 1/4 second / 20 us = 12500  (ok)
                      00257   ; 1/8 second / 50 us =  6250  (ok)
  00000014            00258 TIME      equ  .20
                      00259 #endif ; variant 1 or 2+3 ?
                      00260 
                      00261 
                      00262 ; Clock cycles per timing loop.  See subroutine count_pulses .
                      00263 ;  Usually CYCLES=200 (for 4 MHz crystal,  50 usec - loop)  
                      00264 ;              or 400 (for 20 MHz crystal, 20 usec - loop)
  00000190            00265 CYCLES    equ  TIME*CLOCK/.1000000
                      00266 
  0000C350            00267 GATE_TIME_LOOPS equ  CLOCK/CYCLES       ; number of gate-time loops for ONE SECOND gate time
                      00268 
  000061A8            00269 LAMPTEST_LOOPS  equ  CLOCK/(.2*CYCLES)  ; number of loops for a 0.5 SECOND lamp test after power-on
                      00270 
  00001388            00271 PROGMODE_LOOPS  equ  CLOCK/(.10*CYCLES) ; number of delay loops for display in PROGRAMMING MODE (0.1 sec
                            )
                      00272 
                      00273 ; Configuration of power-saving mode :
                      00274 #if( DEBUG )
                      00275 PSAVE_DELAY_TIME equ .10  ; number of 0.25-sec-intervals before turning off (shorter for debugging)
                      00276 #else
  0000003C            00277 PSAVE_DELAY_TIME equ .60  ; number of 0.25-sec-intervals before turning off (some dozen seconds)
                      00278 #endif
  0000000E            00279 PSAVE_FLASHUP_TIME equ .14 ; number of 0.7(!)-second-intervals between two flashes in power-saving mode
  0000000A            00280 PSAVE_MAX_DIFF   equ .10  ; maximum frequency difference (range-dependent, see below)
                      00281      ; Unit: N times "frequency-resolution", see frequency-range table .
                      00282      ; Example: PSAVE_MAX_DIFF=10 means 10*4Hz in Range 1 (1..3.4 MHz) .
                      00283 
                      00284 
                      00285 ; Menu Indices ... must match the jump table PMDisplay + PMExecute !
  00000000            00286 MI_QUIT   equ  0     ; exit from menu
  00000001            00287 MI_PSAVE  equ  1     ; turn "power save"-option on and off
  00000002            00288 MI_ADD    equ  2     ; save frequency offset to ADD it from now on
  00000003            00289 MI_SUB    equ  3     ; save frequency offset to SUBTRACT it from now on
  00000004            00290 MI_ZERO   equ  4     ; set the frequency offset to ZERO and leave menu
  00000005            00291 MI_STD_IF equ  5     ; jump into the STANDARD INTERMEDIATE FREQUENCY table..
  00000005            00292 MI_INDEX_MAX  equ 5  ; normal menu indices up to MI_INDEX_MAX .
  00000006            00293 MI_IF_1   equ  6     ; show the 1st standard IF
  00000007            00294 MI_IF_2   equ  7     ; show the 2nd standard IF
  00000008            00295 MI_IF_3   equ  8     ; show the 3rd standard IF
  00000009            00296 MI_IF_4   equ  9     ; show the 4th standard IF
  0000000A            00297 MI_IF_5   equ  0x0A  ; show the 4th standard IF
  0000000B            00298 MI_IF_QT  equ  0x0B  ; exit standard IF menu without changing anything
  0000000A            00299 MI_IF_SUBMENU_MAX equ 0x0A
                      00300 
                      00301 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  7


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00302 
                      00303 ;**************************************************************************
                      00304 ;                                                                         *
                      00305 ; File register usage                                                     *
                      00306 ;                                                                         *
                      00307 ;**************************************************************************
                      00308 
                      00309 
                      00310 ; RAM memory (general purpose registers, unfortunately not the same for PIC16F84 & PIC16F628)
                      00311 ;   in PIC16F628: RAM from 0x20..0x7F   (96 bytes, 0x20.. only accessable in Bank0)
                      00312 ;                          0xA0..0xEF   (another 80 bytes in Bank1)
                      00313 ;                          0x120..0x14F (another 48 bytes in Bank2)
                      00314 ;   0x0F0..0x0FF, 0x170..0x17F , 0x1F0..0x1FF are mapped to 0x70..0x7F (same in all banks)
                      00315 ;   So use 0x70..0x7F for context saving in the PIC16F628 and forget 0x0F0.. 0xNNN !
                      00316 ;
                      00317 ;  Note on the 32-bit integer arithmetics as used in this code:
                      00318 ;   - They begin with MOST SIGNIFICANT BYTE in memory, but...
                      00319 ;   - Every byte location has its own label here, which makes debugging
                      00320 ;     with Microchip's simulator much easier (point the mouse on the name
                      00321 ;     of a variable to see what I mean !)
                      00322 ;
                      00323 
  00000027            00324 tens_index     equ  0x27      ; index into the powers-of-ten table
  00000028            00325 divi           equ  0x28      ; power of ten (32 bits)
  00000028            00326 divi_hi        equ  0x28      ; same as 'divi' : HIGH byte
  00000029            00327 divi_mh        equ  0x29      ; MEDIUM HIGH byte
  0000002A            00328 divi_ml        equ  0x2A      ; MEDIUM LOW  byte
  0000002B            00329 divi_lo        equ  0x2B      ; LOW byte
                      00330 
  0000002C            00331 timer0_old     equ  0x2C      ; previous reading from timer0 register
                      00332 
  0000002D            00333 gatecnt_hi     equ  0x2D      ; 16-bit counter (msb first)
  0000002E            00334 gatecnt_lo     equ  0x2E      ; 16-bit counter (lsb last)
                      00335 
  0000002F            00336 bTemp          equ  0x2F      ; temporary 8-bit register, 
                      00337                               ; may be overwritten in ALL subroutines
                      00338 
  00000030            00339 freq           equ  0x30      ; frequency in binary (32 bits)....
  00000030            00340 freq_hi        equ  0x30      ; same location, begins with HIGH byte 
  00000031            00341 freq_mh        equ  0x31      ; ... medium high byte
  00000032            00342 freq_ml        equ  0x32      ; ... medium low byte
  00000033            00343 freq_lo        equ  0x33      ; ... low byte
                      00344 
  00000034            00345 freq2          equ  0x34      ; frequency too, copied for programming mode
  00000034            00346 freq2_hi       equ  0x34      ; same location, begins with HIGH byte 
  00000035            00347 freq2_mh       equ  0x35      ; ... medium high byte
  00000036            00348 freq2_ml       equ  0x36      ; ... medium low byte
  00000037            00349 freq2_lo       equ  0x37      ; ... low byte
                      00350 
  00000038            00351 foffs          equ  0x38      ; frequency too, copied for programming mode
  00000038            00352 foffs_hi       equ  0x38      ; same location, begins with HIGH byte 
  00000039            00353 foffs_mh       equ  0x39      ; ... medium high byte
  0000003A            00354 foffs_ml       equ  0x3A      ; ... medium low byte
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  8


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000003B            00355 foffs_lo       equ  0x3B      ; ... low byte
                      00356 
                      00357 
  0000003C            00358 menu_index     equ  0x3C      ; menu item for programming mode
  0000003D            00359 menu_timer     equ  0x3D      ; used to detect how long a key was pressed
                      00360 
  00000040            00361 digits         equ  0x40      ; frequency as decimal digits (8 bytes)...
  00000040            00362 digit_0        equ  0x40      ; same location as MOST SIGNIFICANT digit, 10-MHz
  00000041            00363 digit_1        equ  0x41      ; usually the 1-MHz-digit
  00000042            00364 digit_2        equ  0x42      ; usually the 100-kHz-digit
  00000043            00365 digit_3        equ  0x43      ; usually the 10-kHz-digit 
  00000044            00366 digit_4        equ  0x44      ; usually the 1-kHz-digit
  00000045            00367 digit_5        equ  0x45      ; usually the 100-Hz-digit
  00000046            00368 digit_6        equ  0x46      ; usually the 10-Hz-digit
  00000047            00369 digit_7        equ  0x47      ; usually the 1-Hz-digit
  00000048            00370 digit_8        equ  0x48      ; must contain a blank character (or trailing zero)
                      00371 
  00000049            00372 display0       equ  0x49      ; display #0 data
  0000004A            00373 display1       equ  0x4A      ; display #1 data
  0000004B            00374 display2       equ  0x4B      ; display #2 data
  0000004C            00375 display3       equ  0x4C      ; display #3 data
  0000004D            00376 display4       equ  0x4D      ; display #4 data
                      00377 
  0000004E            00378 disp_index     equ  0x4E      ; index of the enabled display (0 to 4 for 5-digit display)
  0000004F            00379 disp_timer     equ  0x4F      ; display multiplex timer (5 bits)
                      00380 
  00000050            00381 adjust_shifts  equ  0x50      ; count of 'left shifts' to compensate prescaler+gate time
                      00382 
  00000051            00383 blinker        equ  0x51      ; prescaler for the flashing 1-kHz-dot
                      00384 
  00000052            00385 psave_timer    equ  0x52      ; timer for power-save mode (incremented every 0.25 seconds)
  00000053            00386 psave_freq_lo  equ  0x53      ; low-byte of frequency to detect changes for power-save mode
  00000054            00387 psave_flags    equ  0x54      ; power-saving flags with the following bits:
                      00388 #define PSFLAG_ACTIVE psave_flags,0 ; clear:normal mode,  set:power-saving in action (display blanked)
                      00389 
  00000055            00390 options        equ  0x55      ; display options with the following flag-bits:
                      00391 #define OPT_PWRSAVE options,0 ; clear:normal mode,  set:power-saving mode enabled
  00000056            00392 tx_reg                  equ     0x56
                      00393 
                      00394 
  00000057            00395 bit_count               equ     0x57
  00000058            00396 baud_divider    equ     0x58
  00000059            00397 delay_counter   equ     0x59
  0000005A            00398 print_flags             equ     0x5A
  0000005B            00399 temp                    equ     0x5B
                      00400 
                      00401 
                      00402 ;**************************************************************************
                      00403 ;                                                                         *
                      00404 ; Macros (1)                                                              *
                      00405 ;                                                                         *
                      00406 ;**************************************************************************
                      00407 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE  9


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00408 
                      00409 eep_dw  macro value  ; a DOUBLEWORD split into 4 bytes in the PIC's DATA EEPROM
                      00410            de  (value>>.24), (value>>.16)&0xFF, (value>>8)&0xFF, value&0xFF
                      00411         endm
                      00412 
                      00413 ;**************************************************************************
                      00414 ;                                                                         *
                      00415 ; EEPROM memory  definitions                                              *
                      00416 ;                                                                         *
                      00417 ;**************************************************************************
                      00418   
                      00419   ;     for PIC16F84:   0x00..0x3F were valid EEPROM locations (64 byte)
                      00420   ;     for PIC16F628:  0x00..0x7F are valid EEPROM locations (128 byte)
                      00421 #define EEPROM_ADR_FREQ_OFFSET  0x00  ; EEPROM location for frequency offset
                      00422 #define EEPROM_ADR_STD_IF_TABLE 0x04  ; EEPROM location for standard IF table (4*4 byte)
                      00423 #define EEPROM_ADR_OPTIONS      0x20  ; EEPROM location for "options" (flags)
                      00424 
                      00425 ; This gives warnings with gpasm 'Warning [220] Address exceeds maximum range for this processor.'
                      00426 ; Initial contents of DATA EEPROM:
2100                  00427  org (0x2100+EEPROM_ADR_FREQ_OFFSET)  
                      00428     eep_dw   .0        ; [00..03] initial frequency offset = ZERO
2100   0000 0000 0000     M            de  (.0>>.24),    (.0>>.16)&0xFF,    (.0>>8)&0xFF,    .0&0xFF
       0000 
                      00429 
2104                  00430  org (0x2100+EEPROM_ADR_STD_IF_TABLE)  ;  standard IF table ...
                      00431     eep_dw   .455000   ; [04..07] frequently used in old AM radios 
2104   0000 0006 00F1     M            de  (.455000>>.24), (.455000>>.16)&0xFF, (.455000>>8)&0xFF, .455000&0xFF
       0058 
                      00432     eep_dw  .3999000   ; [08..0B] used in "Miss Mosquita" (DK1HE / DL QRP AG)
2108   0000 003D 0005     M            de  (.3999000>>.24), (.3999000>>.16)&0xFF, (.3999000>>8)&0xFF, .3999000&0xFF
       0018 
                      00433     eep_dw  .4194304   ; [0C..0F] used in other homebrew amateur radio receivers
210C   0000 0040 0000     M            de  (.4194304>>.24), (.4194304>>.16)&0xFF, (.4194304>>8)&0xFF, .4194304&0xFF
       0000 
                      00434     eep_dw  .4433619   ; [10..13] sometimes  used in homebrew amateur radio receivers
2110   0000 0043 00A6     M            de  (.4433619>>.24), (.4433619>>.16)&0xFF, (.4433619>>8)&0xFF, .4433619&0xFF
       00D3 
                      00435     eep_dw .10700000   ; [14..17] frequently used in old FM radios
2114   0000 00A3 0044     M            de  (.10700000>>.24), (.10700000>>.16)&0xFF, (.10700000>>8)&0xFF, .10700000&0xFF
       00E0 
                      00436                        ; [18..1F] reserved for other "preprogrammed" values
                      00437 
2120                  00438  org (0x2100+EEPROM_ADR_OPTIONS)
2120   0000           00439     de      .0         ; [20]     "options" (flags), cleared by default
                      00440 
                      00441 
                      00442 ;**************************************************************************
                      00443 ;                                                                         *
                      00444 ; More Macros                                                             *
                      00445 ;                                                                         *
                      00446 ;**************************************************************************
                      00447 
                      00448 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 10


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00449 ;--------------------------------------------------------------------------
                      00450 ; macros to implement lookup tables - these macros hide the PIC syntax
                      00451 ; used and make the source code more readable 
                      00452 ;   (YHF: CAUTION - BUT THESE MACROS HIDE SOME VERY NASTY PITFALLS . 
                      00453 ;         TABLE MUST NOT CROSS PAGE BORDER DUE TO 'ADDWF PCL, f' ! )
                      00454 ;--------------------------------------------------------------------------
                      00455 
                      00456 cquad  macro value
                      00457           retlw value>>.24              ; high byte
                      00458           retlw (value>>.16)&0xFF       ; middle-high byte
                      00459           retlw (value>>8)&0xFF         ; middle-low  byte
                      00460           retlw value&0xFF              ; low byte
                      00461        endm
                      00462 
                      00463 table  macro label              ; define lookup table
                      00464 
                      00465 label     addwf PCL,f  ; caution: this is 'PCL' only, cannot add to the full 'PC' in a PIC !
                      00466        endm
                      00467 
                      00468 
                      00469 ;--------------------------------------------------------------------------
                      00470 ; add with carry - adds the w register and the carry flag to the file
                      00471 ; register reg, returns the result in <reg> with the carry flag set if overflow
                      00472 ;--------------------------------------------------------------------------
                      00473 
                      00474 addcwf    macro reg
                      00475 
                      00476           local add1,add2
                      00477 
                      00478           bnc add1                      ; branch if no carry set
                      00479 
                      00480           addwf reg , f                 ; add byte
                      00481 
                      00482           incf reg , f                  ; add carry
                      00483           skpnz
                      00484           setc
                      00485 
                      00486           goto add2
                      00487 
                      00488 add1      addwf reg,f                   ; add byte
                      00489 
                      00490 add2
                      00491           endm
                      00492 
                      00493 
                      00494 ;--------------------------------------------------------------------------
                      00495 ; subtract with "no-carry" - subtracts the w register and the no-carry flag
                      00496 ; from the file register reg, returns the result in reg with the no carry flag
                      00497 ; set if underflow
                      00498 ;--------------------------------------------------------------------------
                      00499 
                      00500 subncwf   macro reg
                      00501 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 11


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00502           local sub1,sub2
                      00503 
                      00504           bc sub1                       ; branch if carry set
                      00505           subwf reg, f                  ; subtract byte
                      00506           skpnz                         ; subtract no carry
                      00507           clrc
                      00508           decf reg , f
                      00509           goto sub2
                      00510 sub1      subwf reg , f                 ; subtract byte
                      00511 sub2
                      00512           endm
                      00513 
                      00514 
                      00515 ;--------------------------------------------------------------------------
                      00516 ; MACRO to perform 32-bit addition - adds the four bytes at op2 to the
                      00517 ; three bytes at op1 (most significant bytes first), returns the result in
                      00518 ; op1 with op2 unchanged and the carry flag set if overflow
                      00519 ;--------------------------------------------------------------------------
                      00520 
                      00521 add32     macro op1,op2                 ; op1 := op1 + op2
                      00522 
                      00523           movfw op2+3                   ; add low byte        (bits 7...0)
                      00524           addwf op1+3,f
                      00525 
                      00526           movfw op2+2                   ; add middle-low byte (bits 15..8)
                      00527           addcwf op1+2
                      00528 
                      00529           movfw op2+1                   ; add middle-high byte (bits 23...16)
                      00530           addcwf op1+1
                      00531 
                      00532           movfw op2+0                   ; add high byte       (bits 31...24) 
                      00533           addcwf op1+0
                      00534 
                      00535           endm
                      00536 
                      00537 
                      00538 ;--------------------------------------------------------------------------
                      00539 ; MACRO to perform 32-bit subtraction - subtracts the four bytes at op2
                      00540 ; from the four bytes at op1 (most significant bytes first), returns the
                      00541 ; result in op1 with op2 unchanged and the no carry flag set if underflow
                      00542 ;--------------------------------------------------------------------------
                      00543 
                      00544 sub32     macro op1,op2                 ; op1 := op1 - op2
                      00545 
                      00546           movfw op2+3                   ; subtract low byte 
                      00547           subwf op1+3 , f
                      00548 
                      00549           movfw op2+2                   ; subtract middle low byte
                      00550           subncwf op1+2
                      00551 
                      00552           movfw op2+1                   ; subtract middle high byte
                      00553           subncwf op1+1
                      00554 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 12


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00555           movfw op2+0                   ; subtract high byte
                      00556           subncwf op1+0
                      00557 
                      00558           endm
                      00559 
                      00560 
                      00561 ;--------------------------------------------------------------------------
                      00562 ; MACRO to negate a 32-bit value  (  op := 0 - op ) .
                      00563 ;--------------------------------------------------------------------------
                      00564 
                      00565 neg32  macro op                      ; op1 := 0 - op2
                      00566        local neg_done
                      00567            comf  op,   f             ; invert all 8 bits in high byte  
                      00568            comf  op+1, f             ; invert all 8 bits in middle high byte  
                      00569            comf  op+2, f             ; invert all 8 bits in middle low byte  
                      00570            comf  op+3, f             ; invert all 8 bits in low byte  
                      00571            ; Note at this point 0x000000 would have turned into 0xFFFFFFF .
                      00572            ; Must add ONE to complete the TWO's COMPLIMENT calculation ( -0  = 0 ).
                      00573            ; Note that "incf" affects only the Z flag but not the C flag .
                      00574            incfsz op+3, f            ; increment low byte        (bits 7...0)
                      00575            goto   neg_done           ; if incremented result NOT zero, we're through !
                      00576            incfsz op+2, f            ; increment middle low byte (bits 15...8)
                      00577            goto   neg_done           ; if incremented result NOT zero, ...
                      00578            incfsz op+1, f            ; increment middle high byte (bits 23...16)
                      00579            goto   neg_done           ; if ...
                      00580            incfsz op+0, f            ; increment high byte       (bits 31...24)
                      00581            goto   neg_done           ;
                      00582 neg_done
                      00583        endm
                      00584 
                      00585 
                      00586 
                      00587 
                      00588 ;**********************************************************************
0000                  00589   ORG     0x000             ; processor reset vector
0000   2A2F           00590        goto MainInit        ; go to beginning of program
                      00591 ; (begin of ROM is too precious to waste for ordinary code, see below...)
                      00592 
                      00593 
                      00594 
                      00595 ;**************************************************************************
                      00596 ;                                                                         *
                      00597 ; Lookup tables                                                           *
                      00598 ;    Must be at the start of the code memory to avoid crossing pages !!   *
                      00599 ;                                                                         *
                      00600 ;**************************************************************************
                      00601 
                      00602 ;--------------------------------------------------------------------------
                      00603 ; 7-segment LED data table
                      00604 ;--------------------------------------------------------------------------
                      00605 
                      00606     ; Index 0..9 used for decimal numbers, all other indices defined below :
  0000000A            00607 CHAR_A    equ  .10                 ; Letters A..F = HEX digits, index 10..15
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 13


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  0000000B            00608 CHAR_b    equ  .11                 ;
  0000000C            00609 CHAR_c    equ  .12                 ;
  0000000D            00610 CHAR_d    equ  .13                 ;
  0000000E            00611 CHAR_E    equ  .14                 ; 
  0000000F            00612 CHAR_F    equ  .15                 ; 
  00000010            00613 CHAR_G    equ  .16                 ; Other letters used in "programming" mode 
  00000011            00614 CHAR_H    equ  .17                 ; 
  00000012            00615 CHAR_i    equ  .18                 ; 
                      00616 
  00000013            00617 BLANK     equ  .19                 ; blank display
  00000014            00618 TEST      equ  .20                 ; power-on display test
                      00619 
  00000015            00620 CHAR_P    equ  .21                 ; A few other letters for programming mode...
  00000016            00621 CHAR_r    equ  .22                 ;
  00000017            00622 CHAR_o    equ  .23                 ;   "Prog"
  00000018            00623 CHAR_Q    equ  .24                 ;   "Quit"
  00000019            00624 CHAR_u    equ  .25                 ;
  0000001A            00625 CHAR_t    equ  .26                 ;
  0000001B            00626 CHAR_S    equ  .27                 ;   "Sub"   
  0000001C            00627 CHAR_Z    equ  .28                 ;   "ZEro"
  0000001D            00628 CHAR_I    equ  .29                 ;   large "I" (left aligned!) for "IF"
  0000001E            00629 CHAR_J    equ  .30                 ;
  0000001F            00630 CHAR_k    equ  .31                 ;
  00000020            00631 CHAR_L    equ  .32                 ;
  00000021            00632 CHAR_N    equ  .33                 ;
  00000022            00633 CHAR_V    equ  .34                 ;
  00000023            00634 CHAR_EQ   equ  .35                 ;   "="
                      00635 
                      00636 
                      00637 #if (DISP_VARIANT==1) 
                      00638 DPPOINT_BIT equ  4   ; decimal point bit (same for all digits)
                      00639 #define _A  0x01     ; bitmask for segment A , etc ..
                      00640 #define _B  0x02
                      00641 #define _C  0x20
                      00642 #define _D  0x08
                      00643 #define _E  0x04
                      00644 #define _F  0x40
                      00645 #define _G  0x80
                      00646 #define _DP 0x10
                      00647 #endif   ; DISPLAY VARIANT #1
                      00648 #if (DISP_VARIANT==2) || (DISP_VARIANT==3)
  00000001            00649 DPPOINT_BIT equ  1   ; decimal point bit (same for all digits)
                      00650 #define _A  0x40     ; bitmask for segment A , etc ..
                      00651 #define _B  0x80
                      00652 #define _C  0x04
                      00653 #define _D  0x01
                      00654 #define _E  0x08
                      00655 #define _F  0x10
                      00656 #define _G  0x20
                      00657 #define _DP 0x02
                      00658 #endif   ; DISPLAY VARIANT #2 + #3
                      00659 
                      00660 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 14


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

  00000000            00661 BLANK_PATTERN equ b'00000000'      ; blank display pattern (7-segment code)
                      00662 
                      00663 
                      00664 ;-----------------------------------------------------------------------------
                      00665 ;  Table to convert a decimal digit or a special character into 7-segment-code
                      00666 ;   Note: In DL4YHF's PIC counter, all digits have the same segment connections,
                      00667 ;         so we do not need individual conversion tables for all segments.
                      00668 ;        
                      00669 ;  AAAA
                      00670 ; F    B
                      00671 ; F    B
                      00672 ;  GGGG
                      00673 ; E    C
                      00674 ; E    C
                      00675 ;  DDDD   DP
                      00676 ;
                      00677 ;-----------------------------------------------------------------------------
0001                  00678 Digit2SevenSeg:
0001   0782           00679           addwf PCL,f  ; caution: this is 'PCL' only, not 'PC'. Beware of page borders.
                      00680           ; A = 0, B = 1, C = 5, D = 3, E = 2, F = 6, G = 7, DP = 4
                      00681 #if (COMMON_ANODE)
                      00682  #define SSEG_XORMASK 0xFF  ; since 2005-03-21 ... never tested by the author !
                      00683 #else
                      00684  #define SSEG_XORMASK 0x00  ; for COMMON CATHODE: No bitwise EXOR to the pattern
                      00685 #endif
0002   34DD           00686           retlw (_A+_B+_C+_D+_E+_F   )^SSEG_XORMASK ; ABCDEF. = '0'    ( # 0  )
0003   3484           00687           retlw (   _B+_C            )^SSEG_XORMASK ; .BC.... = '1'    ( # 1  )
0004   34E9           00688           retlw (_A+_B   +_D+_E   +_G)^SSEG_XORMASK ; AB.DE.G = '2'    ( # 2  )
0005   34E5           00689           retlw (_A+_B+_C+_D      +_G)^SSEG_XORMASK ; ABCD..G = '3'    ( # 3  )
0006   34B4           00690           retlw (   _B+_C      +_F+_G)^SSEG_XORMASK ; .BC..FG = '4'    ( # 4  )
0007   3475           00691           retlw (_A   +_C+_D   +_F+_G)^SSEG_XORMASK ; A.CD.FG = '5'    ( # 5  )
0008   347D           00692           retlw (_A   +_C+_D+_E+_F+_G)^SSEG_XORMASK ; A.CDEFG = '6'    ( # 6  )
0009   34C4           00693           retlw (_A+_B+_C            )^SSEG_XORMASK ; ABC.... = '7'    ( # 7  )
000A   34FD           00694           retlw (_A+_B+_C+_D+_E+_F+_G)^SSEG_XORMASK ; ABCDEFG = '8'    ( # 8  )
000B   34F5           00695           retlw (_A+_B+_C+_D   +_F+_G)^SSEG_XORMASK ; ABCD.FG = '9'    ( # 9  )
000C   34FC           00696           retlw (_A+_B+_C   +_E+_F+_G)^SSEG_XORMASK ; ABC.EFG = 'A'    ( # 10 )
000D   343D           00697           retlw (      _C+_D+_E+_F+_G)^SSEG_XORMASK ; ..CDEFG = 'b'    ( # 11 )
000E   3429           00698           retlw (         _D+_E   +_G)^SSEG_XORMASK ; ...DE.G = 'c'    ( # 12 )
000F   34AD           00699           retlw (   _B+_C+_D+_E   +_G)^SSEG_XORMASK ; .BCDE.G = 'd'    ( # 13 )
0010   3479           00700           retlw (_A      +_D+_E+_F+_G)^SSEG_XORMASK ; A..DEFG = 'E'    ( # 14 )
0011   3478           00701           retlw (_A         +_E+_F+_G)^SSEG_XORMASK ; A...EFG = 'F'    ( # 15 )
0012   345D           00702           retlw (_A   +_C+_D+_E+_F   )^SSEG_XORMASK ; A.CDEF. = 'G'    ( # 16 )
0013   34BC           00703           retlw (   _B+_C   +_E+_F+_G)^SSEG_XORMASK ; .BC.EFG = 'H'    ( # 17 )
0014   3408           00704           retlw (            _E      )^SSEG_XORMASK ; ....E.. = 'i'    ( # 18 )
                      00705 
0015   3400           00706           retlw (BLANK_PATTERN       )^SSEG_XORMASK ; ....... = ' '    ( # 19 )
0016   34FF           00707           retlw (b'11111111'         )^SSEG_XORMASK ; all segments on  ( # 20 )
                      00708 
                      00709           ; A few more letters for programming mode :
0017   34F8           00710           retlw (_A+_B      +_E+_F+_G)^SSEG_XORMASK ; AB..EFG = 'P'    ( # 21 )
0018   3428           00711           retlw (            _E   +_G)^SSEG_XORMASK ; ....E.G = 'r'    ( # 22 )
0019   342D           00712           retlw (      _C+_D+_E   +_G)^SSEG_XORMASK ; ..CDE.G = 'o'    ( # 23 )
001A   34F4           00713           retlw (_A+_B+_C      +_F+_G)^SSEG_XORMASK ; ABC..FG = 'Q'    ( # 24 )
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 15


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

001B   340D           00714           retlw (      _C+_D+_E      )^SSEG_XORMASK ; ..CDE.. = 'u'    ( # 25 )
001C   3439           00715           retlw (         _D+_E+_F+_G)^SSEG_XORMASK ; ...DEFG = 't'    ( # 26 )
001D   3475           00716           retlw (_A   +_C+_D   +_F+_G)^SSEG_XORMASK ; A.CD.FG = 'S'    ( # 27 )
001E   34E9           00717           retlw (_A+_B   +_D+_E   +_G)^SSEG_XORMASK ; AB.DE.G = 'Z'    ( # 28 )
001F   3418           00718           retlw (            _E+_F   )^SSEG_XORMASK ; ....EF. = 'I'    ( # 29 )
0020   3485           00719           retlw (   _B+_C+_D         )^SSEG_XORMASK ; .BCD..  = 'J'    ( # 30 )
0021   3439           00720           retlw (         _D+_E+_F+_G)^SSEG_XORMASK ; ...DEFG = 'k'    ( # 31 )
0022   3419           00721           retlw (         _D+_E+_F   )^SSEG_XORMASK ; ...DEF. = 'L'    ( # 32 )
0023   34DC           00722           retlw (_A+_B+_C   +_E+_F   )^SSEG_XORMASK ; ABC.EF. = 'N'    ( # 33 )
0024   341D           00723           retlw (      _C+_D+_E+_F   )^SSEG_XORMASK ; ..CDEF. = 'V'    ( # 34 )
0025   3421           00724           retlw (         _D      +_G)^SSEG_XORMASK ; ...D..G = '='    ( # 35 )
                      00725 
                      00726 
                      00727 
                      00728 ;--------------------------------------------------------------------------
                      00729 ; Table to control which 7-segment display is enabled. Displays are usually
                      00730 ; COMMON CATHODE (variants 1+2) so pulled low to enable.
                      00731 ; For DISP_VARIANT=3 (COMMON ANODE), the digit-driving pattern is inverted.
                      00732 ; Input:   W = 0 means the MOST SIGNIFICANT DIGIT (the leftmost one), etc.
                      00733 ; Result:  VALUE to be written to ENABLE_PORT to activate the digit
                      00734 ;--------------------------------------------------------------------------
0026                  00735 Digit2MuxValue:     ; 
0026   0782           00736           addwf PCL,f  ; caution: this is 'PCL' only, not 'PC'
                      00737           ; Note: If the program counter is affected, a command requires to instruction cycles (=8 osc c
                            ycles)
                      00738 #if (DISP_VARIANT==1)  ; muliplexer values for DISPLAY VARIANT #1 :
                      00739           retlw b'11110111'        ; most significant digit is on   PA3 (!)
                      00740           retlw b'11111110'        ; next less significant dig. on  PA0 (!)
                      00741           retlw b'11111011'        ; next less significant dig. on  PA2 (!)
                      00742           retlw b'11111101'        ; 4th (sometimes the last) digit PA1 (!)
                      00743           retlw b'11111111'        ; 5th (OPTIONAL) least significant digit = NOT (PA3+PA2+PA1+PA0)
                      00744 #endif   ; DISPLAY VARIANT #1
                      00745 #if (DISP_VARIANT==2)  ; muliplexer values for DISPLAY VARIANT #2 (5 digits, COMMON CATHODE) :
0027   34F7           00746           retlw b'11110111'        ; most significant digit is on   PA3 (!)
0028   34FB           00747           retlw b'11111011'        ; next less significant dig. on  PA2 (!!)
0029   34FE           00748           retlw b'11111110'        ; next less significant dig. on  PA0 (!!)
002A   34FD           00749           retlw b'11111101'        ; 4th (sometimes the last) digit PA1 (!)
002B   34FF           00750           retlw b'11111111'        ; 5th (OPTIONAL) least significant digit = NOT (PA3+PA2+PA1+PA0)
                      00751 #endif   ; DISPLAY VARIANT #2
                      00752 #if (DISP_VARIANT==3)  ; muliplexer values for DISPLAY VARIANT #3 (5 digits, COMMON ANODE) :
                      00753                        ; Unused bits (b7..b4) are left HIGH as above .
                      00754           retlw b'11111000'        ; most significant digit is on   PA3 (!)
                      00755           retlw b'11110100'        ; next less significant dig. on  PA2 (!!)
                      00756           retlw b'11110001'        ; next less significant dig. on  PA0 (!!)
                      00757           retlw b'11110010'        ; 4th (sometimes the last) digit PA1 (!)
                      00758           retlw b'11110000'        ; 5th (OPTIONAL) least significant digit = NOT (PA3+PA2+PA1+PA0)
                      00759 #endif   ; DISPLAY VARIANT #2
                      00760 
                      00761 
                      00762 
                      00763 ;--------------------------------------------------------------------------
                      00764 ; Powers-of-ten table (32 bits, most significant byte first)
                      00765 ;   Based on an idea by James Hutchby (MadLab, 1996) .
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 16


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00766 ;   Modified for 32-bit arithmetic by Wolfgang Buescher (2004).
                      00767 ;--------------------------------------------------------------------------
002C   0782           00768 TensTable  addwf PCL,f  
                      00769            cquad   .10000000  ; 10 million is sufficient for the counter itself
002D   3400               M           retlw .10000000>>.24          ; high byte
002E   3498               M           retlw (.10000000>>.16)&0xFF   ; middle-high byte
002F   3496               M           retlw (.10000000>>8)&0xFF     ; middle-low  byte
0030   3480               M           retlw .10000000&0xFF          ; low byte
                      00770            cquad   .1000000
0031   3400               M           retlw .1000000>>.24           ; high byte
0032   340F               M           retlw (.1000000>>.16)&0xFF    ; middle-high byte
0033   3442               M           retlw (.1000000>>8)&0xFF      ; middle-low  byte
0034   3440               M           retlw .1000000&0xFF           ; low byte
                      00771            cquad   .100000
0035   3400               M           retlw .100000>>.24            ; high byte
0036   3401               M           retlw (.100000>>.16)&0xFF     ; middle-high byte
0037   3486               M           retlw (.100000>>8)&0xFF       ; middle-low  byte
0038   34A0               M           retlw .100000&0xFF            ; low byte
                      00772            cquad   .10000
0039   3400               M           retlw .10000>>.24             ; high byte
003A   3400               M           retlw (.10000>>.16)&0xFF      ; middle-high byte
003B   3427               M           retlw (.10000>>8)&0xFF        ; middle-low  byte
003C   3410               M           retlw .10000&0xFF             ; low byte
                      00773            cquad   .1000
003D   3400               M           retlw .1000>>.24              ; high byte
003E   3400               M           retlw (.1000>>.16)&0xFF       ; middle-high byte
003F   3403               M           retlw (.1000>>8)&0xFF         ; middle-low  byte
0040   34E8               M           retlw .1000&0xFF              ; low byte
                      00774            cquad   .100
0041   3400               M           retlw .100>>.24               ; high byte
0042   3400               M           retlw (.100>>.16)&0xFF        ; middle-high byte
0043   3400               M           retlw (.100>>8)&0xFF          ; middle-low  byte
0044   3464               M           retlw .100&0xFF               ; low byte
                      00775            cquad   .10
0045   3400               M           retlw .10>>.24                ; high byte
0046   3400               M           retlw (.10>>.16)&0xFF         ; middle-high byte
0047   3400               M           retlw (.10>>8)&0xFF           ; middle-low  byte
0048   340A               M           retlw .10&0xFF                ; low byte
                      00776            cquad   .1
0049   3400               M           retlw .1>>.24                 ; high byte
004A   3400               M           retlw (.1>>.16)&0xFF          ; middle-high byte
004B   3400               M           retlw (.1>>8)&0xFF            ; middle-low  byte
004C   3401               M           retlw .1&0xFF                 ; low byte
                      00777 
                      00778 
                      00779 ;--------------------------------------------------------------------------
                      00780 ; DISPLAY jump table for programming mode .
                      00781 ;   Loads the display-strings like "quit" etc into the display latches.
                      00782 ; Input parameter:  menu_index (0 .. MI_INDEX_MAX)
                      00783 ; Output placed in  display0..display3
                      00784 ;
                      00785 ;--------------------------------------------------------------------------
004D                  00786 PMDisplay:
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 17


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

004D   083C           00787           movfw  menu_index  ; load menu index into W register
004E   0782           00788           addwf  PCL, f      ; add W to lower part of program counter (computed jump)
004F   2B43           00789           goto   PmDisp_Quit ; show "quit" (quit programming mode)
0050   2B4E           00790           goto   PmDisp_PSave; show "PSave"(power-saving mode on/off)
0051   2B64           00791           goto   PmDisp_Add  ; show "add " (add frequency offset)
0052   2B6C           00792           goto   PmDisp_Sub  ; show "sub " (subtract frequency offset)
0053   2B74           00793           goto   PmDisp_Zero ; show "Zero" (set frequency offset to zero)
0054   2B7C           00794           goto   PmDisp_StIF ; show "StdIF" (select standard IF from table)
0055   2B87           00795           goto   PmDisp_IF_1 ; show 1st standard IF from table
0056   2B89           00796           goto   PmDisp_IF_2 ; show 2nd standard IF from table
0057   2B8B           00797           goto   PmDisp_IF_3 ; show 3rd standard IF from table
0058   2B8D           00798           goto   PmDisp_IF_4 ; show 4th standard IF from table
0059   2B8F           00799           goto   PmDisp_IF_5 ; show 5th standard IF from table
005A   2B43           00800           goto   PmDisp_Quit ; show "quit" (quit STANDARD IF menu)
                      00801           ; Add more display strings here if needed !
                      00802 
                      00803 ;--------------------------------------------------------------------------
                      00804 ; EXECUTION jump table for programming mode .
                      00805 ;   Executes the commands "quit", "psave", "add", "sub", "zero", etc.
                      00806 ; Input parameter:  menu_index (0 .. MI_INDEX_MAX)
                      00807 ;--------------------------------------------------------------------------
005B                  00808 PMExecute:   ; Execute the function belonging to menu_index
005B   083C           00809           movfw  menu_index  ; load menu index into W register
005C   0782           00810           addwf  PCL, f      ; add W to lower part of program counter (computed jump)
005D   2B9A           00811           goto   PmExec_Quit ; quit programming mode
005E   2B9B           00812           goto   PmExec_PSave; turn power-saving mode on/off
005F   2BA2           00813           goto   PmExec_Add  ; add frequency offset from now on
0060   2BB0           00814           goto   PmExec_Sub  ; subtract frequency offset from now on
0061   2BBD           00815           goto   PmExec_Zero ; set frequency offset to zero
0062   2BC2           00816           goto   PmExec_StIF ; switch to  "Standard IF selection mode"
0063   2BC5           00817           goto   PmExec_SelIF ; select 1st standard IF from table
0064   2BC5           00818           goto   PmExec_SelIF ; select 2nd standard IF from table
0065   2BC5           00819           goto   PmExec_SelIF ; select 3rd standard IF from table
0066   2BC5           00820           goto   PmExec_SelIF ; select 4th standard IF from table
0067   2B9A           00821           goto   PmExec_Quit ; quit STANDARD IF menu
                      00822           ; Add more jumps here if needed !
                      00823 
                      00824 
                      00825 
                      00826 ;**************************************************************************
                      00827 ;                                                                         *
                      00828 ; Procedures                                                              *
                      00829 ;                                                                         *
                      00830 ;**************************************************************************
                      00831 
                      00832 
                      00833 ;--------------------------------------------------------------------------
                      00834 ;  Configure the prescaler for TIMER 0 in the PIC's OPTION register .
                      00835 ;--------------------------------------------------------------------------
                      00836 
                      00837 ; Description of the OPTION register, from the PIC16F628 data sheet:
                      00838 ; bit 7: RBPU: PORTB Pull-up Enable bit
                      00839 ;        1 = PORTB pull-ups are disabled
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 18


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00840 ;        0 = PORTB pull-ups are enabled by individual port latch values
                      00841 ; bit 6: INTEDG: Interrupt Edge Select bit
                      00842 ;        1 = Interrupt on rising edge of RB0/INT pin
                      00843 ;        0 = Interrupt on falling edge of RB0/INT pin
                      00844 ; bit 5: T0CS: TMR0 Clock Source Select bit
                      00845 ;        1 = Transition on RA4/T0CKI pin
                      00846 ;        0 = Internal instruction cycle clock (CLKOUT)
                      00847 ; bit 4: T0SE: TMR0 Source Edge Select bit
                      00848 ;        1 = Increment on high-to-low transition on RA4/T0CKI pin
                      00849 ;        0 = Increment on low-to-high transition on RA4/T0CKI pin
                      00850 ; bit 3: PSA: Prescaler Assignment bit
                      00851 ;        1 = Prescaler is assigned to the WDT
                      00852 ;        0 = Prescaler is assigned to the Timer0 module
                      00853 ; bit 2-0: PS2:PS0: Prescaler Rate Select bits, here shown for TMR0 :
                      00854 ;     000  = 1 : 2
                      00855 ; ... 111  = 1 : 256
                      00856 ;        Note: to count EVERY pulse (1 : 1) with TMR0, the prescaler
                      00857 ;              must be assigned to the WATCHDOG TIMER (WDT) !
                      00858 ; Some examples (for the OPTION register, parameter in W for SetPrescaler):
  00000020            00859 PSC_DIV_BY_2   equ  b'00100000'   ; let prescaler divide TMR0 by two
  00000021            00860 PSC_DIV_BY_4   equ  b'00100001'   ; let prescaler divide TMR0 by   4
  00000022            00861 PSC_DIV_BY_8   equ  b'00100010'   ; let prescaler divide TMR0 by   8
  00000023            00862 PSC_DIV_BY_16  equ  b'00100011'   ; let prescaler divide TMR0 by  16
  00000024            00863 PSC_DIV_BY_32  equ  b'00100100'   ; let prescaler divide TMR0 by  32
  00000025            00864 PSC_DIV_BY_64  equ  b'00100101'   ; let prescaler divide TMR0 by  64
  00000026            00865 PSC_DIV_BY_128 equ  b'00100110'   ; let prescaler divide TMR0 by 128
  00000027            00866 PSC_DIV_BY_256 equ  b'00100111'   ; let prescaler divide TMR0 by 256
                      00867 
0068                  00868 SetPrescaler:  ; copy W into OPTION register, avoid watchdog trouble
0068   0064           00869           clrwdt     ; recommended by Microchip ("switching prescaler assignment") 
                      00870           errorlevel -302 ; Turn off banking message for the next few instructions..
0069   1683           00871           bsf   STATUS, RP0            ;! setting RP0 enables access to OPTION reg
                      00872                ; option register is in bank1. i know. thanks for the warning.
006A   0081           00873           movwf OPTION_REG             ;! ex: "option" command (yucc)
006B   1283           00874           bcf   STATUS, RP0            ;! clearing RP0 for normal register access
                      00875           errorlevel +302 ; Enable banking message again
006C   3400           00876           retlw 0
                      00877 
                      00878 
006D                  00879 PrescalerOff:  ; turn the prescaler for TMR0 "off" 
                      00880                ; (actually done by assigning the prescaler to the watchdog timer)
006D   0064           00881           clrwdt                        ; clear watchdog timer
006E   0181           00882           clrf  TMR0                    ; clear timer 0 AND PRESCALER(!)
                      00883           errorlevel -302 ; Turn off banking message for the next few instructions..
006F   1683           00884           bsf   STATUS, RP0            ;! setting RP0 enables access to OPTION reg
                      00885                ; option register is in bank1. i know. thanks for the warning.
0070   3027           00886           movlw b'00100111'            ;! recommended by Microchip when
                      00887                                        ;! changing prescaler assignment from TMR0 to WDT
0071   0081           00888           movwf OPTION_REG             ;! ex: "option" command (yucc)
0072   0064           00889           clrwdt                       ;! clear watchdog again
0073   302F           00890           movlw b'00101111'            ;! bit 3 set means PS assigned to WDT now
0074   0081           00891           movwf OPTION_REG             ;! ex: "option" command (yucc)
0075   1283           00892           bcf   STATUS, RP0            ;! clearing RP0 for normal register access
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 19


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00893           errorlevel +302 ; Enable banking message again
0076   3400           00894           retlw 0
                      00895 
                      00896 
                      00897 ;--------------------------------------------------------------------------
                      00898 ; Power-saving subroutine: Puts the PIC to sleep for ROUGHLY 100 milliseconds .
                      00899 ;  - crystal oscillator turned OFF during this phase
                      00900 ;  - only the internal RC-oscillator for the watchdog keeps running
                      00901 ;  - expiration of watchdog during sleep does NOT reset the PIC, 
                      00902 ;    only wakes it up again so normal operation may resume 
                      00903 ;  - LED display will be off during this time 
                      00904 ;--------------------------------------------------------------------------
0077                  00905 Sleep150ms:  ; go to sleep for approx. 150 milliseconds, and then RETURN (no reset)
                      00906    ; Details on the PIC's watchdog timer (from PIC16F628 datasheet) :
                      00907    ; > The WDT has a nominal timeout period of 18 ms (with
                      00908    ; > no prescaler). The timeout periods vary with temperature,
                      00909    ; > VDD and process variations from part to part (see
                      00910    ; > DC specs).
                      00911    ; > The Watchdog Timer is a free running on-chip RC oscillator which does 
                      00912    ; > not require any external components. This RC oscillator is separate 
                      00913    ; > from the ER oscillator of the CLKIN pin. That means that the WDT will run, 
                      00914    ; > even if the clock on the OSC1 and OSC2 pins of the device has been stopped, 
                      00915    ; > for example, by execution of a SLEEP instruction. 
                      00916    ; > During normal operation, a WDT timeout generates a device RESET.
                      00917    ; > If the device is in SLEEP mode, a WDT timeout causes the device to wake-up 
                      00918    ; > and continue with normal operation.
                      00919    ; > The WDT can be permanently disabled by programming the configuration bit 
                      00920    ; > WDTE as clear .
                      00921    ; In other words, to use the watchdog-timer for "temporary sleep" here ,
                      00922    ; it must be ENABLED in the configuration word when programming the PIC.
                      00923    ;  (because its not possible to turn it on via software if it's not on).
                      00924    ; But once the watchdog timer is ON, it must be FED periodically otherwise
                      00925    ; it will reset the PIC during normal operation !
                      00926    ; Here (in the frequency counter), the prescaler remains assigned to timer0
                      00927    ; so the watchdog interval is ~ 18 milliseconds (+/-, RC-oscillator) .
                      00928    ; > The CLRWDT and SLEEP instructions clear the WDT and the postscaler, 
                      00929    ; > if assigned to the WDT, and prevent it from timing out and generating
                      00930    ; >  a device RESET. The TO bit in the STATUS register will be cleared upon
                      00931    ; > a Watchdog Timer timeout.
                      00932 #if(COMMON_CATHODE)  ; display with COMMON CATHODE : 
0077   3000           00933           movlw 0x00                    ; segment drivers LOW to turn off
                      00934 #else  ; not COMMON CATHODE but COMMON ANODE:
                      00935           movlw 0xFF                    ; segment drivers HIGH to turn off
                      00936 #endif
                      00937 
                      00938 #ifndef RS232_OUT
                      00939           movwf LEDS_PORT               ; turn LED segments off
                      00940 #else
                      00941 #ifdef  NON_INVERTING_RS232_OUT 
0078   1106           00942                 bcf     LEDS_PORT,      2                               ; RS232 on RB2 to zero
                      00943 #else
                      00944                 bsf     LEDS_PORT,      2                               ; RS232 on RB2 to one
                      00945 #endif
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 20


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00946 ; NON_INVERTING_RS232_OUT
                      00947 #endif
                      00948 ; RS232_OUT
                      00949           ; Note: The global interrupt-enable flag (GIE) is off in this application !
                      00950           ; To avoid unintended wake-up on 'interrupt' (port level change),
                      00951           ; disable all interrupt-SOURCES: Clear T0IE,INTE,RBIE,PEIE too :
0079   018B           00952           clrf  INTCON                  ; disable all interrupts during SLEEP mode
007A   0064           00953           clrwdt                        ; clear watchdog timer
007B   0181           00954           clrf  TMR0                    ; clear timer 0 AND PRESCALER(!)
                      00955           errorlevel -302 ; Turn off banking message for the next few instructions..
007C   1683           00956           bsf   STATUS, RP0            ;! setting RP0 enables access to OPTION reg
                      00957                ; option register is in bank1. i know. thanks for the warning.
007D   302B           00958           movlw b'00101011'            ;! assign PS to WDT; divide by 8 FOR WDT(!)
007E   0081           00959           movwf OPTION_REG             ;! ex: "option" command (yucc)
007F   1283           00960           bcf   STATUS, RP0            ;! clearing RP0 for normal register access
                      00961           errorlevel +302 ; Enable banking message again
0080   0063           00962           sleep                         ; sleep for approx 18 ms (one watchdog interval)
                      00963           ; The SLEEP command clears the Watchdog Timer and stops the main oscillator.
                      00964           ; Only the internal watchdog timer keeps running.
                      00965           ; The WDT is is also cleared when the device wakes-up from SLEEP, 
                      00966           ; regardless of the source of wake-up, so no need for 'clrwdt' here !
0081   0000           00967           nop    ; arrived here, slept for ~ 8 times 18 milliseconds
0082   0008           00968           return ; end  Sleep150ms
                      00969               
                      00970 
                      00971 
                      00972 
                      00973 ;--------------------------------------------------------------------------
                      00974 ; Convert a character into LEDs data for the 7-segment displays, fed with
                      00975 ; the character in w.  Bit 7 set means 'decimal point AFTER this digit' .
                      00976 ;--------------------------------------------------------------------------
                      00977 ; WAS print 5 digits with MHz and kHz indication/.
                      00978 
                      00979 conv      macro display                 ; macro for duplicate code
                      00980           movwf display                 ; save decimal point bit (msb)
                      00981           andlw 7fh                     ; mask bit
                      00982 
                      00983 #ifndef RS232_OUT
                      00984           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                      00985           btfsc display,7               ; check bit 7 = decimal point ?
                      00986 
                      00987 #if(COMMON_CATHODE)
                      00988           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                      00989 #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
                      00990           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                      00991 #endif
                      00992                 movwf   display                 ; set display data register
                      00993 
                      00994 #else   ; RS232_OUT
                      00995 
                      00996 #ifdef RS232_PRINT_FIELD_3
                      00997                 movwf   temp                                    ; save w
                      00998 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 21


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      00999 ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                      01000                 bcf             print_flags,    NO_INPUT_FLAG
                      01001 ; no jumps in macro
                      01002                 movlw   BLANK
                      01003                 subwf   temp, w
                      01004                 btfsc   STATUS, Z
                      01005                 bsf             print_flags,    NO_INPUT_FLAG
                      01006 
                      01007 ; get back value to print
                      01008                 movfw   temp
                      01009 ; test if anything other then zero, if so display it
                      01010                 btfss   print_flags,    NO_INPUT_FLAG
                      01011                 call    tx_digit_in_w
                      01012 
                      01013 ; test for decimal point
                      01014                 btfsc   display, 7
                      01015                 call    tx_dot
                      01016 #endif  ; RS232_PRINT_FIELD_3
                      01017 
                      01018 #endif
                      01019                 
                      01020           endm
                      01021 
                      01022 ; 7 segment out
0083                  01023 conv_char0:   ; display digit #0  (leftmost, or MOST SIGNIFICANT digit)
                      01024           conv  display0
0083   00C9               M           movwf display0                ; save decimal point bit (msb)
0084   397F               M           andlw 7fh                     ; mask bit
                          M 
                          M #ifndef RS232_OUT
                          M           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                          M           btfsc display0,7              ; check bit 7 = decimal point ?
                          M 
                          M #if(COMMON_CATHODE)
                          M           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                          M #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
                          M           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                          M #endif
                          M                 movwf   display0                ; set display data register
                          M 
                          M #else   ; RS232_OUT
                          M 
                          M #ifdef RS232_PRINT_FIELD_3
                          M                 movwf   temp                                    ; save w
                          M 
                          M ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                          M                 bcf             print_flags,    NO_INPUT_FLAG
                          M ; no jumps in macro
                          M                 movlw   BLANK
                          M                 subwf   temp, w
                          M                 btfsc   STATUS, Z
                          M                 bsf             print_flags,    NO_INPUT_FLAG
                          M 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 22


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M ; get back value to print
                          M                 movfw   temp
                          M ; test if anything other then zero, if so display it
                          M                 btfss   print_flags,    NO_INPUT_FLAG
                          M                 call    tx_digit_in_w
                          M 
                          M ; test for decimal point
                          M                 btfsc   display0, 7
                          M                 call    tx_dot
                          M #endif  ; RS232_PRINT_FIELD_3
                          M 
                          M #endif
                          M                 
0085   3400           01025           retlw 0
                      01026 
0086                  01027 conv_char1:   ; display #1
                      01028           conv  display1
0086   00CA               M           movwf display1                ; save decimal point bit (msb)
0087   397F               M           andlw 7fh                     ; mask bit
                          M 
                          M #ifndef RS232_OUT
                          M           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                          M           btfsc display1,7              ; check bit 7 = decimal point ?
                          M 
                          M #if(COMMON_CATHODE)
                          M           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                          M #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
                          M           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                          M #endif
                          M                 movwf   display1                ; set display data register
                          M 
                          M #else   ; RS232_OUT
                          M 
                          M #ifdef RS232_PRINT_FIELD_3
                          M                 movwf   temp                                    ; save w
                          M 
                          M ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                          M                 bcf             print_flags,    NO_INPUT_FLAG
                          M ; no jumps in macro
                          M                 movlw   BLANK
                          M                 subwf   temp, w
                          M                 btfsc   STATUS, Z
                          M                 bsf             print_flags,    NO_INPUT_FLAG
                          M 
                          M ; get back value to print
                          M                 movfw   temp
                          M ; test if anything other then zero, if so display it
                          M                 btfss   print_flags,    NO_INPUT_FLAG
                          M                 call    tx_digit_in_w
                          M 
                          M ; test for decimal point
                          M                 btfsc   display1, 7
                          M                 call    tx_dot
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 23


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M #endif  ; RS232_PRINT_FIELD_3
                          M 
                          M #endif
                          M                 
0088   3400           01029           retlw 0
                      01030 
0089                  01031 conv_char2:   ; display #2
                      01032           conv  display2
0089   00CB               M           movwf display2                ; save decimal point bit (msb)
008A   397F               M           andlw 7fh                     ; mask bit
                          M 
                          M #ifndef RS232_OUT
                          M           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                          M           btfsc display2,7              ; check bit 7 = decimal point ?
                          M 
                          M #if(COMMON_CATHODE)
                          M           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                          M #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
                          M           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                          M #endif
                          M                 movwf   display2                ; set display data register
                          M 
                          M #else   ; RS232_OUT
                          M 
                          M #ifdef RS232_PRINT_FIELD_3
                          M                 movwf   temp                                    ; save w
                          M 
                          M ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                          M                 bcf             print_flags,    NO_INPUT_FLAG
                          M ; no jumps in macro
                          M                 movlw   BLANK
                          M                 subwf   temp, w
                          M                 btfsc   STATUS, Z
                          M                 bsf             print_flags,    NO_INPUT_FLAG
                          M 
                          M ; get back value to print
                          M                 movfw   temp
                          M ; test if anything other then zero, if so display it
                          M                 btfss   print_flags,    NO_INPUT_FLAG
                          M                 call    tx_digit_in_w
                          M 
                          M ; test for decimal point
                          M                 btfsc   display2, 7
                          M                 call    tx_dot
                          M #endif  ; RS232_PRINT_FIELD_3
                          M 
                          M #endif
                          M                 
008B   3400           01033           retlw 0
                      01034 
008C                  01035 conv_char3:   ; display #3
                      01036           conv  display3
008C   00CC               M           movwf display3                ; save decimal point bit (msb)
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 24


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

008D   397F               M           andlw 7fh                     ; mask bit
                          M 
                          M #ifndef RS232_OUT
                          M           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                          M           btfsc display3,7              ; check bit 7 = decimal point ?
                          M 
                          M #if(COMMON_CATHODE)
                          M           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                          M #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
                          M           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                          M #endif
                          M                 movwf   display3                ; set display data register
                          M 
                          M #else   ; RS232_OUT
                          M 
                          M #ifdef RS232_PRINT_FIELD_3
                          M                 movwf   temp                                    ; save w
                          M 
                          M ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                          M                 bcf             print_flags,    NO_INPUT_FLAG
                          M ; no jumps in macro
                          M                 movlw   BLANK
                          M                 subwf   temp, w
                          M                 btfsc   STATUS, Z
                          M                 bsf             print_flags,    NO_INPUT_FLAG
                          M 
                          M ; get back value to print
                          M                 movfw   temp
                          M ; test if anything other then zero, if so display it
                          M                 btfss   print_flags,    NO_INPUT_FLAG
                          M                 call    tx_digit_in_w
                          M 
                          M ; test for decimal point
                          M                 btfsc   display3, 7
                          M                 call    tx_dot
                          M #endif  ; RS232_PRINT_FIELD_3
                          M 
                          M #endif
                          M                 
008E   3400           01037           retlw 0
                      01038 
008F                  01039 conv_char4:   ; display #4  (rightmost, or LEAST SIGNIFICANT digit, "ones")
                      01040           conv  display4
008F   00CD               M           movwf display4                ; save decimal point bit (msb)
0090   397F               M           andlw 7fh                     ; mask bit
                          M 
                          M #ifndef RS232_OUT
                          M           call  Digit2SevenSeg          ; convert digit into 7-segment-code via table
                          M           btfsc display4,7              ; check bit 7 = decimal point ?
                          M 
                          M #if(COMMON_CATHODE)
                          M           iorlw 1<<DPPOINT_BIT          ; include decimal point if bit 7 set (bitwise OR)
                          M #else  ; not COMMON CATHODE but COMMON ANODE: decimal point must be 'AND'ed to pattern:
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 25


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M           andlw (1<<DPPOINT_BIT)^0xFF   ; include decimal point if bit 7 set (bitwise AND)
                          M #endif
                          M                 movwf   display4                ; set display data register
                          M 
                          M #else   ; RS232_OUT
                          M 
                          M #ifdef RS232_PRINT_FIELD_3
                          M                 movwf   temp                                    ; save w
                          M 
                          M ; BLANK, displayed as 'C', indicates no input, going to skip printing those.
                          M                 bcf             print_flags,    NO_INPUT_FLAG
                          M ; no jumps in macro
                          M                 movlw   BLANK
                          M                 subwf   temp, w
                          M                 btfsc   STATUS, Z
                          M                 bsf             print_flags,    NO_INPUT_FLAG
                          M 
                          M ; get back value to print
                          M                 movfw   temp
                          M ; test if anything other then zero, if so display it
                          M                 btfss   print_flags,    NO_INPUT_FLAG
                          M                 call    tx_digit_in_w
                          M 
                          M ; test for decimal point
                          M                 btfsc   display4, 7
                          M                 call    tx_dot
                          M #endif  ; RS232_PRINT_FIELD_3
                          M 
                          M #endif
                          M                 
                      01041 
                      01042 #ifdef RS232_OUT
                      01043 
                      01044 #ifdef RS232_PRINT_FIELD_3
                      01045 ; print a space
                      01046                 movlw ' '
                      01047                 call tx_w
                      01048 
                      01049 ; test if to print kHz or MHz
                      01050                 btfsc   print_flags, KILOHERTZ_FLAG
                      01051                 goto    print_kilo
                      01052 ; print 'M'
                      01053                 movlw   'M'
                      01054                 call    tx_w
                      01055                 goto    print_hertz
                      01056 
                      01057 print_kilo:     
                      01058                 movlw   'k'
                      01059                 call    tx_w
                      01060 
                      01061 ; say Hz
                      01062 print_hertz:
                      01063                 movlw   'H'
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 26


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01064                 call    tx_w
                      01065 
                      01066                 movlw   'z'
                      01067                 call    tx_w
                      01068 #endif  RS232_PRINT_FIELD_3
                      01069 
                      01070 ; send a CR LF
0091   300A           01071                 movlw   D'10'
0092   210D           01072                 call    tx_w
                      01073                 
0093   300D           01074                 movlw   D'13'
0094   210D           01075                 call    tx_w
                      01076 
                      01077 #endif  ; RS232_OUT
                      01078 
0095   3400           01079           retlw 0
                      01080 ; 7 segment out
                      01081 
                      01082 ;--------------------------------------------------------------------------
                      01083 ; Fill the 5-digit display latch with blank characters
                      01084 ;--------------------------------------------------------------------------
0096                  01085 ClearDisplay:
0096   3000           01086           movlw BLANK_PATTERN
0097   00C9           01087           movwf display0
0098   00CA           01088           movwf display1
0099   00CB           01089           movwf display2
009A   00CC           01090           movwf display3
009B   00CD           01091           movwf display4
009C   3400           01092           retlw 0
                      01093 
                      01094 
                      01095 
                      01096 ;--------------------------------------------------------------------------
                      01097 ; Save a single Byte in the PIC's Data-EEPROM.
                      01098 ;  Input parameters:
                      01099 ;    INDF = *FSR    contains byte to be written (was once EEDATA)
                      01100 ;    w              contains EEPROM address offset (i.e. "destination index")
                      01101 ;
                      01102 ;--------------------------------------------------------------------------
                      01103         ; write to EEPROM data memory as explained in the 16F628 data sheet.
                      01104         ; EEDATA and EEADR must have been set before calling this subroutine
                      01105         ; (optimized for the keyer-state-machine).
                      01106         ; CAUTION : What the lousy datasheet DS40300B wont tell you:
                      01107         ;           The example given there for the 16F628 is WRONG ! 
                      01108         ;           All EEPROM regs are in BANK1 for the 16F628. 
                      01109         ;           In the PIC16F84, some were in BANK0 others in BANK1..
                      01110         ; In the PIC16F628, things are much different... all EEPROM regs are in BANK1 !
009D                  01111 SaveInEEPROM:    ; save "INDF" = *FSR   in EEPROM[<w>]
009D   138B           01112          bcf     INTCON, GIE           ; disable INTs
                      01113          errorlevel -302 ; Turn off banking message for the next few instructions..
009E   1683           01114          bsf     STATUS, RP0         ;!; Bank1 for "EEADR" access, PIC16F628 ONLY (not F84)
009F   009B           01115          movwf   EEADR               ;!; write into EEPROM address register (BANK1 !!)
00A0   1283           01116          bcf     STATUS, RP0         ;!; Bank0 to read "bStorageData"
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 27


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

00A1   0800           01117          movfw   INDF                ; ; w := *FSR (read source data from BANK 0)
00A2   1683           01118          bsf     STATUS, RP0         ;!; Bank1 for "EEDATA" access, PIC16F628 ONLY (not F84)
00A3   009A           01119          movwf   EEDATA              ;!; EEDATA(in BANK1) := w  (BANK1; F628 only, NOT F84 !!!)
00A4   151C           01120          bsf     EECON1, WREN        ;!; set WRite ENable
00A5   138B           01121          bcf     INTCON, GIE         ;!; Is this REALLY required as in DS40300B Example 13-2 ?
00A6   3055           01122          movlw   055h                ;!;
00A7   009D           01123          movwf   EECON2              ;!; write 55h
00A8   30AA           01124          movlw   0AAh                ;!;
00A9   009D           01125          movwf   EECON2              ;!; write AAh
00AA   149C           01126          bsf     EECON1, WR          ;!; set WR bit, begin write
                      01127          ; wait until write access to the EEPROM is complete.
00AB   189C           01128 SaveEW:  btfsc   EECON1, WR          ;!; WR is cleared after completion of write
00AC   28AB           01129          goto    SaveEW              ;!; WR=1, write access not finished yet
                      01130          ; Arrived here: the EEPROM write is ready
00AD   111C           01131          bcf     EECON1, WREN        ;!; disable further WRites
00AE   1283           01132          bcf     STATUS, RP0         ;!; Bank0 for normal access
                      01133          errorlevel +302 ; Enable banking message again
                      01134    ;     bsf     INTCON, GIE           ; enable INTs ? NOT IN THIS APPLICATION !
00AF   3400           01135          retlw   0  ; end SaveInEEPROM
                      01136 
                      01137 
                      01138 ;--------------------------------------------------------------------------
                      01139 ; Read a single Byte from the PIC's Data-EEPROM.
                      01140 ;  Input parameters:
                      01141 ;    w    contains EEPROM address offset (i.e. "source index")
                      01142 ;         will *NOT* be modified to simplify block-read .
                      01143 ;    FSR  points to the memory location where the byte shall be placed.
                      01144 ;
                      01145 ;  Result:
                      01146 ;     INDF = *FSR  returns the read byte
                      01147 ;--------------------------------------------------------------------------
                      01148         ; Caution: EEDATA and EEADR have been moved from Bank0(16F84) to Bank1(16F628)
                      01149         ;          and the example from the datasheet telling you to switch to 
                      01150         ;          bank0 to access EEDATA is rubbish (DS40300B page 93 example 13-1).
00B0                  01151 EEPROM_ReadByte:    ; read ONE byte from the PIC's data EEPROM
00B0   00AF           01152         movwf   bTemp       ; save W
00B1   138B           01153         bcf     INTCON, GIE  ; disable INTs
                      01154         errorlevel -302 ; Turn off banking message for the next few instructions..
00B2   1683           01155         bsf     STATUS, RP0  ; Bank1 for ***ALL*** EEPROM registers in 16F628 (!)
00B3   009B           01156         movwf   EEADR        ;! write into EEPROM address register
00B4   141C           01157         bsf     EECON1, RD   ;! set "Read"-Flag for EEPROM
                      01158                              ;   why is EECON1.RD not cleared in MPLAB-sim ?!?
00B5   081A           01159         movf    EEDATA, w    ;! read byte from EEPROM latch
00B6   1283           01160         bcf     STATUS, RP0  ;! normal access to Bank0
                      01161         errorlevel +302 ; Enable banking message again
                      01162     ;   bsf     INTCON, GIE  ; re-enable interrupts ? NOT IN THIS APPLICATION !
00B7   0080           01163         movwf   INDF         ; place result in *FSR
00B8   082F           01164         movfw   bTemp       ; restore W
00B9   0008           01165         return               ; back to caller
                      01166  ; end EEPROM_ReadByte
                      01167 
00BA                  01168 EEPROM_Read4Byte: ; read FOUR bytes from the PIC's data EEPROM.
                      01169         ;  Input parameters:
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 28


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01170         ;    w    contains EEPROM address offset (i.e. "source index")
                      01171         ;         will *NOT* be modified to simplify block-read .
                      01172         ;    FSR  points to the memory location where the byte shall be placed.
00BA   20B0           01173         call    EEPROM_ReadByte ; *FSR = EEPROM[w]   (usually bits 31..24)
00BB   3E01           01174         addlw   1               ; next source address
00BC   0A84           01175         incf    FSR , f         ; next destination address
00BD   20B0           01176         call    EEPROM_ReadByte ; *FSR = EEPROM[w]   (usually bits 23..16)
00BE   3E01           01177         addlw   1               ; next source address
00BF   0A84           01178         incf    FSR , f         ; next destination address
00C0   20B0           01179         call    EEPROM_ReadByte ; *FSR = EEPROM[w]   (usually bits 15..8) 
00C1   3E01           01180         addlw   1               ; next source address
00C2   0A84           01181         incf    FSR , f         ; next destination address
00C3   28B0           01182         goto    EEPROM_ReadByte ; *FSR = EEPROM[w]   (usually bits  7..0) 
                      01183  ; end EEPROM_Read4Byte
                      01184 
                      01185 
                      01186 
                      01187 
                      01188 ;--------------------------------------------------------------------------
                      01189 ; Count pulses, fed with the number of loop iterations for the gate time .
                      01190 ;               WHILE counting, the multiplexed LED display is updated .
                      01191 ;               Watchdog is fed in this loop !
                      01192 ; Input:    Count of gate-time-loops in 'gatecnt_hi'+'gatecnt_lo' (16 bit).
                      01193 ; Returns:  The number of pulses in 'freq' (clock cycles in [])
                      01194 ;--------------------------------------------------------------------------
00C4                  01195 count_pulses:
00C4   01B0           01196           clrf freq_hi                  ; clear pulse counter (bits 31..24)
00C5   01B1           01197           clrf freq_mh                  ; bits 23..16
00C6   01B2           01198           clrf freq_ml                  ; bits 16..8
00C7   01B3           01199           clrf freq_lo                  ; bits  7..0 
                      01200 
00C8   01AC           01201           clrf timer0_old               ; 'old' value of timer0 to detect toggling MSB
00C9   0181           01202           clrf TMR0                     ; timer register (PIC's hardware timer, 8 bit)
                      01203 
00CA   0000           01204           nop                           ; 2 instruction cycle delay
00CB   0000           01205           nop                           ; after writing to TMR0  (MPLAB-SIM: set breakpoint + clear stop
                            watch here)
                      01206 
                      01207 
                      01208 ; --------------- start of critial timing loop >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
                      01209 
                      01210 ; The following timing loop must take a well-defined time in total per
                      01211 ; iteration, usually 50 (or 20) microseconds, which can be precisely achieved 
                      01212 ; with a 4-MHz-crystal (or 20 MHz for variant 2+3) .
                      01213 ; This gives a basic delay for the frequency counter's gate time .
                      01214 ;    The frequency at the input of TIMER 0 (not the prescaler)
                      01215 ;    can not exceed f_crystal / 4,  
                      01216 ;    and every HIGH->LOW transition of bit7 in TIMER0 must be polled here.
                      01217 ;  This is safe because ..
                      01218 ;    Variant 1:  With a 4-MHz-crystal, Timer0 can count up to 1 MHz input, 
                      01219 ;                MSB toggles every (128/1MHz) = 128 us, polled every 50us  -> ok.
                      01220 ;    Variant 2:  With a 20-MHz-crystal, Timer0 can count up to 4 (not 5?!) MHz input,
                      01221 ;                MSB toggles every (128/4MHz) = 32 us, polled every 20us -> ok.
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 29


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01222 
                      01223 ;  The numbers in square brackets below are the INSTRUCTION NUMBER within the loop.
                      01224 ;  (not the count of oscillator cycles for a single command, which is always 4).
                      01225 ;  These values can be checked with the "Stopwatch" function in MPLAB-SIM.
                      01226 ;  The goal is to let this loop take EXACTLY <TIME> microseconds (50us or 20us).
                      01227 
00CC   084E           01228 count1    movfw disp_index              ; [1] get the current digit number (disp_index = 0..4)
00CD   2026           01229           call  Digit2MuxValue          ; [2,3,4,5,6,7] display (6 commands including call+retlw)
00CE   00AF           01230           movwf bTemp                   ; [8] save the bit pattern for the multiplexer port
00CF   3049           01231           movlw display0                ; [9]  get the LED display data for the current digit...
00D0   074E           01232           addwf disp_index,w            ; [10] add current digit number to address of LED data
00D1   0084           01233           movwf FSR                     ; [11] move address into the PIC's poor 'data pointer'
                      01234 #ifndef RS232_OUT
                      01235           movfw INDF                    ; [12] w := *(FSR) use indirection register to read from table
                      01236           movwf LEDS_PORT               ; [13] set the LED segments
                      01237 #else
                      01238 ; leave port B alone, so as not to disturb RS232 software out.
00D2   0000           01239                 nop
00D3   0000           01240                 nop
                      01241 #endif
                      01242 
00D4   082F           01243           movfw bTemp                   ; [14] get the mupliplexer pattern (hurry, hurry !)
00D5   0085           01244           movwf ENABLE_PORT             ; [15] set the LED multiplexer
                      01245 
00D6   0ACF           01246           incf  disp_timer,f            ; [16] increment display-multiplex timer 
00D7   1B4F           01247           btfsc disp_timer,6            ; [17] (6-bit prescaler)
00D8   0ACE           01248           incf  disp_index,f            ; [18] next display if rolled over
00D9   134F           01249           bcf   disp_timer,6            ; [19] limit disp_timer to 6 bits (!)
00DA   084E           01250           movfw disp_index              ; [20] limit display index to  0...4
00DB   3C04           01251           sublw .4                      ; [21] subtract #4 - W register -> C=0(!) if result negative (W>
                            4)
00DC   1C03           01252           btfss STATUS,C                ; [22] skip next instruction if C=1 (#4-W >= 0)
00DD   01CE           01253           clrf  disp_index              ; [23] if C=0 (disp_index>4) then disp_index=0
                      01254 
                      01255 ; the following fragments of code always take the same number of clock
                      01256 ; cycles to execute, irrespective of whether the skips take place or not .
                      01257 ; Here still in 'count_pulses'.
                      01258 
00DE   0801           01259           movfw TMR0                    ; [24] read least significant byte of 
00DF   00B3           01260           movwf freq_lo                 ; [25]  pulse counter (bits 7..0)
                      01261 
00E0   3001           01262           movlw 1                       ; [26] determine if timer 0 has rolled
00E1   1FAC           01263           btfss timer0_old,7            ; [27] over (rolled over if msb was 
00E2   0103           01264           clrw                          ; [28] previously set and now isn't) 
00E3   1BB3           01265           btfsc freq_lo,7               ; [29]
00E4   0103           01266           clrw                          ; [30]
                      01267 
00E5   07B2           01268           addwf freq_ml,f               ; [31] increment high bytes of pulse counter
00E6   1803           01269           skpnc                         ; [32] if low byte rolled over 
00E7   0AB1           01270           incf freq_mh,f                ; [33] (mh = "medium high byte" of counter)
                      01271                                         ; NOTE: we are not modifying freq_hi here !
                      01272                                         ;       Bits 31..24 may be used later when multiplying with some
                             factor
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 30


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01273                                         ;       (2^n) to compensate for the ASYNCHRON PRESCALER !
                      01274 
00E8   1BB1           01275           btfsc freq_mh,7               ; [34] overflow (freq > 7fffffh) ? 
00E9   2908           01276           goto  count3                  ; [35] branch if yes
                      01277 
00EA   0833           01278           movfw freq_lo                 ; [36] save previous value from timer 0 
00EB   00AC           01279           movwf timer0_old              ; [37]
                      01280 
00EC   08AE           01281           tstf gatecnt_lo               ; [38] check inner gate-time counter, LOW byte
00ED   1903           01282           skpnz                         ; [39] only decrement h-byte if l-byte zero
00EE   03AD           01283           decf gatecnt_hi,f             ; [40]  decrement gate-time counter, HIGH byte
00EF   03AE           01284           decf gatecnt_lo,f             ; [41] always decrement gate-time counter, LOW byte
                      01285 
                      01286 #if (DISP_VARIANT==1)  ; only 50 instruction cycles per loop in DISPLAY VARIANT 1 (f_xtal=4 MHz, t_loop=
                            50us)
                      01287           ; Got some instruction cycles left ? Insert a few NOPs to bring to total loop time to 50us.
                      01288           clrwdt                        ; [42] (ex: nop, but since 2006-05-28 the dog must be fed !)
                      01289           nop                           ; [43]
                      01290           nop                           ; [44] 
                      01291           nop                           ; [45]  ugh, what a waste of precious CPU power ;-)
                      01292 
                      01293           movfw gatecnt_hi              ; [46] counter = 0 ? 
                      01294           iorwf gatecnt_lo,w            ; [47]
                      01295           skpz                          ; [48]
                      01296           goto count1                   ; [49,50]  goto always takes TWO instruction cycles
                      01297 #else   ; For VARIANTS 2+3 : 100 instruction cycles per loop  
                      01298         ; (f_xtal=20 MHz, t_loop=20us, t_instr=4/20MHz=0.2us)
                      01299         ; Some time may be used for a nice software-based PULSE WIDTH MODULATION
                      01300         ; of the display intensity ... or other goodies/gimmicks one fine day !
00F0   0064           01301           clrwdt                        ; [42] (ex: nop, but since 2006-05-28 the dog must be fed !)
00F1   300C           01302           movlw .12                     ; [43] load additional delay loops (X=12, see below) into W
00F2   3EFF           01303 WasteT1:  addlw 0xFF                    ; [44,   48, .. ]
00F3   1D03           01304           btfss STATUS, Z               ; [45,   49, .. ]      eats 4(!) INSTRUCTION CYCLES per loop
00F4   28F2           01305           goto  WasteT1                 ; [46+47,50+51, .. ]
                      01306                           ; Check this with MPLAB-SIM: here, after loop: [43 + 4*X], with X=12: [91]
00F5   0000           01307           nop                           ; [91]
00F6   0000           01308           nop                           ; [92]
00F7   0000           01309           nop                           ; [93]
00F8   0000           01310           nop                           ; [94] 
00F9   0000           01311           nop                           ; [95]
00FA   082D           01312           movfw gatecnt_hi              ; [96] counter = 0 ? 
00FB   042E           01313           iorwf gatecnt_lo,w            ; [97]
00FC   1D03           01314           skpz                          ; [98]
00FD   28CC           01315           goto count1                   ; [99,50]  goto always takes TWO instruction cycles
                      01316 #endif ; variant 1 or variant 2/3 ?
                      01317 
                      01318 ; <<<<<<<<<<<<<<<<<<<<<<<< end of timing loop -----------------------------
                      01319 
00FE   0801           01320           movfw TMR0                    ; get final value from timer 0
00FF   00B3           01321           movwf freq_lo
                      01322 
0100   3001           01323           movlw 1                       ; determine if timer 0 has rolled
0101   1FAC           01324           btfss timer0_old,7            ; over (rolled over if msb was
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 31


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0102   0103           01325           clrw                          ; previously set and now isn't)
0103   1BB3           01326           btfsc freq_lo,7
0104   0103           01327           clrw
                      01328 
0105   07B2           01329           addwf freq_ml,f               ; increment high bytes of pulse
0106   1803           01330           skpnc                         ; counter if low byte rolled
0107   0AB1           01331           incf freq_mh,f                ; over
                      01332 
0108   3400           01333 count3    retlw 0
                      01334 
                      01335 ; end of routine 'count_pulses'.   Result now in   freq_lo..freq_hi.
                      01336 
                      01337 
                      01338 #ifdef RS232_OUT
0109                  01339 tx_dot:
0109   302E           01340         movlw   '.'
010A   210D           01341         call    tx_w
010B   0008           01342         return
                      01343 
                      01344 
                      01345 ; send_one_char
                      01346 ; the actual RS232 transmission routine, half-duplex, no-flow-control.
                      01347 ; See AN510 for an explanation
010C                  01348 tx_digit_in_w:  
010C   3E30           01349     addlw   '0'                     ; zero
010D                  01350 tx_w:
010D   1283 1303      01351         banksel 0
                      01352 
                      01353 ;       return
                      01354 
                      01355 ;       movlw   'A'
010F   00D6           01356         movwf   tx_reg                                  ; move W (char to send) to TXReg
                      01357 
0110   3008           01358         movlw   0x08
0111   00D7           01359         movwf   bit_count                               ; send 8 bits
                      01360 
                      01361 ; send start bit
                      01362 #ifdef NON_INVERTING_RS232_OUT
0112   1506           01363         bsf             RS232_PORT,     RS232_BIT
                      01364 #else
                      01365         bcf             RS232_PORT,     RS232_BIT
                      01366 #endif
                      01367 
0113   0000           01368         nop
0114   0000           01369         nop
0115   0000           01370         nop
0116   0000           01371         nop
0117   212C           01372         call    bit_delay
                      01373 
                      01374 ; send data bits
0118                  01375 send_next_bit:
0118   1003           01376         bcf     STATUS, C
0119   0CD6           01377         rrf     tx_reg, 1                               ; rotate TXReg
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 32


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01378 
011A   1803           01379         btfsc   STATUS, C
011B   291F           01380         goto    set_tx
                      01381 
011C                  01382 clear_tx:
011C   0000           01383         nop                                                             ; to get equal set/clear times
                      01384 #ifdef NON_INVERTING_RS232_OUT
011D   1506           01385         bsf             RS232_PORT,     RS232_BIT
                      01386 #else
                      01387         bcf             RS232_PORT,     RS232_BIT
                      01388 #endif
011E   2921           01389         goto    ready_tx
                      01390 
011F                  01391 set_tx:
                      01392 #ifdef NON_INVERTING_RS232_OUT
011F   1106           01393         bcf             RS232_PORT,     RS232_BIT
                      01394 #else
                      01395         bsf             RS232_PORT,     RS232_BIT
                      01396 #endif
0120   2921           01397         goto    ready_tx
                      01398         
0121                  01399 ready_tx:
0121   212C           01400         call    bit_delay               
0122   0BD7           01401         decfsz  bit_count,1                             ; decrement bit counter (8..0)
0123   2918           01402         goto    send_next_bit                   ; loop for next data bit
                      01403 
0124   0000           01404         nop
0125   0000           01405         nop
0126   0000           01406         nop
0127   0000           01407         nop
0128   0000           01408         nop
                      01409 
                      01410 ; send first stop bit
                      01411 #ifdef NON_INVERTING_RS232_OUT
0129   1106           01412         bcf             RS232_PORT,     RS232_BIT
                      01413 #else
                      01414         bsf             RS232_PORT,     RS232_BIT
                      01415 #endif
012A   212C           01416         call    bit_delay
                      01417 
                      01418 ; send second stop bit
                      01419 ;       call    bit_delay
                      01420 
012B   0008           01421         return
                      01422 
                      01423 
                      01424 ; This routine is calibrated with BIT_DELAY to 104 us, that makes  BAUD_DIVIDER 1 for 9600 Bd, 2 for 480
                            0 Bd, 4 for 2400 Bd, 8 for 1200 Bd, 16 for 600 Bd, 32 for 300 Bd, 64 for 150 Bd, and 128 for 75 
012C                  01425 bit_delay:      
                      01426 ; prevent watchdog from interrupting serial com
012C   0064           01427         clrwdt                                                  ; should be called on a regular basis
                      01428 
                      01429 ; Multiply bit delay for lower baudrates.
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 33


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

012D   3008           01430         movlw   BAUD_DIVIDER
012E   00D8           01431         movwf   baud_divider
012F                  01432 baud_divider_loop:
                      01433 
                      01434 ; this is the delay of about 104 uS for 9600 Bd
012F   30A5           01435         movlw   BIT_DELAY                               ; move baud delay constant to W
0130   00D9           01436         movwf   delay_counter                   ; initialize delay counter
0131                  01437 us100_delay_loop:
Message[305]: Using default destination of 1 (file).
0131   0BD9           01438         decfsz  delay_counter                   ; decrement delay counter
0132   2931           01439         goto    us100_delay_loop
                      01440 
                      01441 
Message[305]: Using default destination of 1 (file).
0133   0BD8           01442         decfsz  baud_divider
0134   292F           01443         goto    baud_divider_loop
                      01444 
0135   0008           01445         return
                      01446 #endif
                      01447 ; RS232_OUT
                      01448 
                      01449 
                      01450 ;--------------------------------------------------------------------------
                      01451 ; Convert *FSR (32 bit) into BCD and show it on the display .
                      01452 ;  Input :  INDF = *FSR, 32-bit integer.  
                      01453 ;  Bad side effect : CONTENTS OF <freq> will be lost !!
                      01454 ;--------------------------------------------------------------------------
0136                  01455 ShowInt32_FSR   ; Convert <*FSR> (32 bit integer) to 8 BCD-digits ...
0136   0800           01456           movfw  INDF        ; W   := *FSR   , load LOW byte
0137   0A84           01457           incf   FSR , f     ; FSR := FSR + 1
0138   00B0           01458           movwf  freq        ; freq.hi := W
0139   0800           01459           movfw  INDF        ; W   := *FSR   , load MIDDLE LOW byte
013A   0A84           01460           incf   FSR , f     ; FSR := FSR + 1
013B   00B1           01461           movwf  freq+1      ; freq.mh := W
013C   0800           01462           movfw  INDF        ; W   := *FSR   , load MIDDLE HIGH byte
013D   0A84           01463           incf   FSR , f     ; FSR := FSR + 1
013E   00B2           01464           movwf  freq+2      ; freq.ml := W
013F   0800           01465           movfw  INDF        ; W   := *FSR   , load HIGH byte 
0140   0A84           01466           incf   FSR , f     ; FSR := FSR + 1
0141   00B3           01467           movwf  freq+3      ; freq.lo := W
                      01468           ; continue with CvtAndDisplayFreq !
                      01469 
                      01470 ;--------------------------------------------------------------------------
                      01471 ; Convert <freq> into BCD and show it on the display .
                      01472 ;  Input :  freq, 32-bit integer.  CONTENTS OF <freq> will be lost !!
                      01473 ;--------------------------------------------------------------------------
0142                  01474 CvtAndDisplayFreq  ; Convert <freq>(32 bit integer) to 8 BCD-digits ...
                      01475 
0142   01A7           01476           clrf  tens_index              ; initialise the table index
                      01477 
0143   3040           01478           movlw digits                  ; initialise the indirection register
0144   0084           01479           movwf FSR                     ; ( FSR="pointer"; *FSR=INDF)
                      01480 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 34


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0145                  01481 conv1     ; Loop for ALL POWERS OF TEN in the lookup table..
0145   0064           01482           clrwdt                        ; feed the watchdog (may stay a bit longer)
0146   0827           01483           movfw tens_index              ; fetch the next power of ten
0147   202C           01484           call  TensTable               ; (32 bits) from the lookup table
0148   00A8           01485           movwf divi+0                  ; and store in divi
0149   0AA7           01486           incf  tens_index , f          ; this was the HIGH byte
                      01487 
014A   0827           01488           movfw tens_index
014B   202C           01489           call  TensTable
014C   00A9           01490           movwf divi+1
014D   0AA7           01491           incf  tens_index , f          ; this was the MIDDLE-HIGH byte
                      01492 
014E   0827           01493           movfw tens_index
014F   202C           01494           call  TensTable
0150   00AA           01495           movwf divi+2
0151   0AA7           01496           incf  tens_index , f          ; this was the MIDDLE-LOW byte
                      01497 
0152   0827           01498           movfw tens_index
0153   202C           01499           call  TensTable
0154   00AB           01500           movwf divi+3
0155   0AA7           01501           incf  tens_index , f          ; and this was the LOW-byte of a power of ten
                      01502 
                      01503           ; ex: clrf 0  ; clear the decimal digit .. but address ZERO is called 'INDF' these days !
0156   0180           01504           clrf  INDF                    ; *FSR = 0
                      01505 
0157                  01506 conv2     ; Loop to repeatedly subtract divi from freq (32-bit subtract)
                      01507           ;         until underflow while incrementing the decimal digit.
                      01508           sub32 freq,divi               ; freq := freq - divi  (with divi = 10 power N)
                          M 
0157   082B               M           movfw divi+3                  ; subtract low byte 
0158   02B3               M           subwf freq+3 , f
                          M 
0159   082A               M           movfw divi+2                  ; subtract middle low byte
                          M           subncwf freq+2
                          M 
  0000                    M           local sub1,sub2
                          M 
015A   1803 2961          M           bc sub1                       ; branch if carry set
015C   02B2               M           subwf freq+2, f               ; subtract byte
015D   1903               M           skpnz                         ; subtract no carry
015E   1003               M           clrc
015F   03B2               M           decf freq+2 , f
0160   2962               M           goto sub2
0161   02B2               M sub1      subwf freq+2 , f              ; subtract byte
0162                      M sub2
                          M 
0162   0829               M           movfw divi+1                  ; subtract middle high byte
                          M           subncwf freq+1
                          M 
  0000                    M           local sub1,sub2
                          M 
0163   1803 296A          M           bc sub1                       ; branch if carry set
0165   02B1               M           subwf freq+1, f               ; subtract byte
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 35


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0166   1903               M           skpnz                         ; subtract no carry
0167   1003               M           clrc
0168   03B1               M           decf freq+1 , f
0169   296B               M           goto sub2
016A   02B1               M sub1      subwf freq+1 , f              ; subtract byte
016B                      M sub2
                          M 
016B   0828               M           movfw divi+0                  ; subtract high byte
                          M           subncwf freq+0
                          M 
  0000                    M           local sub1,sub2
                          M 
016C   1803 2973          M           bc sub1                       ; branch if carry set
016E   02B0               M           subwf freq+0, f               ; subtract byte
016F   1903               M           skpnz                         ; subtract no carry
0170   1003               M           clrc
0171   03B0               M           decf freq+0 , f
0172   2974               M           goto sub2
0173   02B0               M sub1      subwf freq+0 , f              ; subtract byte
0174                      M sub2
                          M 
0174   1C03 2978      01509           bnc conv3                     ; 
0176   0A80           01510           incf INDF , f                 ;    The RESULT will be written back to freq, 
0177   2957           01511           goto conv2                    ;    in other words 'freq' will be lost !
                      01512 
                      01513 conv3     add32 freq,divi               ; freq := freq+divi;  ready for next digit
                          M 
0178   082B               M           movfw divi+3                  ; add low byte        (bits 7...0)
0179   07B3               M           addwf freq+3,f
                          M 
017A   082A               M           movfw divi+2                  ; add middle-low byte (bits 15..8)
                          M           addcwf freq+2
                          M 
  0000                    M           local add1,add2
                          M 
017B   1C03 2982          M           bnc add1                      ; branch if no carry set
                          M 
017D   07B2               M           addwf freq+2 , f              ; add byte
                          M 
017E   0AB2               M           incf freq+2 , f               ; add carry
017F   1903               M           skpnz
0180   1403               M           setc
                          M 
0181   2983               M           goto add2
                          M 
0182   07B2               M add1      addwf freq+2,f                ; add byte
                          M 
0183                      M add2
                          M 
0183   0829               M           movfw divi+1                  ; add middle-high byte (bits 23...16)
                          M           addcwf freq+1
                          M 
  0000                    M           local add1,add2
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 36


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M 
0184   1C03 298B          M           bnc add1                      ; branch if no carry set
                          M 
0186   07B1               M           addwf freq+1 , f              ; add byte
                          M 
0187   0AB1               M           incf freq+1 , f               ; add carry
0188   1903               M           skpnz
0189   1403               M           setc
                          M 
018A   298C               M           goto add2
                          M 
018B   07B1               M add1      addwf freq+1,f                ; add byte
                          M 
018C                      M add2
                          M 
018C   0828               M           movfw divi+0                  ; add high byte       (bits 31...24) 
                          M           addcwf freq+0
                          M 
  0000                    M           local add1,add2
                          M 
018D   1C03 2994          M           bnc add1                      ; branch if no carry set
                          M 
018F   07B0               M           addwf freq+0 , f              ; add byte
                          M 
0190   0AB0               M           incf freq+0 , f               ; add carry
0191   1903               M           skpnz
0192   1403               M           setc
                          M 
0193   2995               M           goto add2
                          M 
0194   07B0               M add1      addwf freq+0,f                ; add byte
                          M 
0195                      M add2
                          M 
0195   0A84           01514           incf FSR , f                  ; step to next decimal digit
0196   3020           01515           movlw 8*4                     ; 8 x 4-byte entries in TensTable
0197   0227           01516           subwf tens_index,w
0198   1D03 2945      01517           bnz conv1                     ; loop until end of table
                      01518 
                      01519 ;--------------------------------------------------------------------------
                      01520 ; displays the frequency in decimal
                      01521 ;--------------------------------------------------------------------------
                      01522 
019A                  01523 display_freq:
                      01524 ; Display the decimal digits according to the following rules
                      01525 ; 000000A => "0.00A"
                      01526 ; 00000AB => "0.0AB"
                      01527 ; 0000ABC => "0.ABC"
                      01528 ; 000ABCD => "A.BCD"
                      01529 ; 00ABCDE => "AB.CD"
                      01530 ; 0ABCDEF => "ABC.D"
                      01531 ; ABCDEFG => "ABCD."
                      01532 ;    Modified a lot by WoBu to display kHz as well as MHz :
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 37


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01533 ;      If the decimal point means kHz, it flashes.
                      01534 ;      If it means MHz, it is on permanently.
                      01535 ;      24 bit unsigned integer could count up to 16777216 (16 mio, slightly over 7 digits)
                      01536 ;      which was not enough for a 50 MHz counter, so switched to 32-bit arithmetic .
                      01537 ;      
                      01538 
                      01539 #ifdef RS232_OUT
                      01540 
                      01541 #ifdef RS232_PRINT_FIELD_1
                      01542 ; WAS print 8 digits as one field for parsin gby user programs, no leading zero suppression
                      01543 ; print_value simple
019A   3040           01544         movlw   digits
019B   0084           01545         movwf   FSR
                      01546 
019C   0800           01547         movfw   INDF
019D   210C           01548         call    tx_digit_in_w
                      01549 
Message[305]: Using default destination of 1 (file).
019E   0A84           01550         incf    FSR
019F   0800           01551         movfw   INDF
01A0   210C           01552         call    tx_digit_in_w
                      01553 
Message[305]: Using default destination of 1 (file).
01A1   0A84           01554         incf    FSR
01A2   0800           01555         movfw   INDF
01A3   210C           01556         call    tx_digit_in_w
                      01557 
Message[305]: Using default destination of 1 (file).
01A4   0A84           01558         incf    FSR
01A5   0800           01559         movfw   INDF
01A6   210C           01560         call    tx_digit_in_w
                      01561 
Message[305]: Using default destination of 1 (file).
01A7   0A84           01562         incf    FSR
01A8   0800           01563         movfw   INDF
01A9   210C           01564         call    tx_digit_in_w
                      01565 
Message[305]: Using default destination of 1 (file).
01AA   0A84           01566         incf    FSR
01AB   0800           01567         movfw   INDF
01AC   210C           01568         call    tx_digit_in_w
                      01569 
Message[305]: Using default destination of 1 (file).
01AD   0A84           01570         incf    FSR
01AE   0800           01571         movfw   INDF
01AF   210C           01572         call    tx_digit_in_w
                      01573 
Message[305]: Using default destination of 1 (file).
01B0   0A84           01574         incf    FSR
01B1   0800           01575         movfw   INDF
01B2   210C           01576         call    tx_digit_in_w
                      01577 
                      01578 ; print 2 spaces
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 38


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

01B3   3020           01579         movlw   ' '
01B4   210D           01580         call    tx_w    
                      01581 
01B5   3020           01582         movlw   ' '
01B6   210D           01583         call    tx_w    
                      01584 
                      01585 #endif ; RS232_PRINT_FIELD_1
                      01586 
                      01587 
                      01588 #ifdef RS232_PRINT_FIELD_2
                      01589 ; print value in Hz, with leading zero surpression
                      01590 ; print_value: thoudands separated by commas
01B7   165A           01591         bsf             print_flags,    ZERO_SUPPRESSION_FLAG
                      01592 
01B8   3040           01593         movlw   digits
01B9   0084           01594         movwf   FSR
01BA   0880           01595         tstf    INDF
01BB   1903 29C3      01596         bz              pri_1000000
                      01597         
01BD                  01598 pri_10000000:
01BD   125A           01599         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01BE   0800           01600         movfw   INDF
01BF   0880           01601         tstf    INDF
01C0   1903 29CE      01602         bz              pri_100000
01C2   210C           01603         call    tx_digit_in_w
                      01604 
01C3                  01605 pri_1000000:
Message[305]: Using default destination of 1 (file).
01C3   0A84           01606         incf    FSR
                      01607 ; test if zero supression active
01C4   1E5A           01608         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01C5   29C9           01609         goto    pri_a
01C6   0880           01610         tstf    INDF
01C7   1903 29CE      01611         bz              pri_100000
01C9                  01612 pri_a:
01C9   125A           01613         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01CA   0800           01614         movfw   INDF
01CB   210C           01615         call    tx_digit_in_w
                      01616 
01CC   302C           01617         movlw   ','
01CD   210D           01618         call    tx_w
                      01619 
01CE                  01620 pri_100000:
Message[305]: Using default destination of 1 (file).
01CE   0A84           01621         incf    FSR
01CF   1E5A           01622         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01D0   29D4           01623         goto    pri_b
01D1   0880           01624         tstf    INDF
01D2   1903 29D7      01625         bz              pri_10000
01D4                  01626 pri_b:
01D4   125A           01627         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01D5   0800           01628         movfw   INDF
01D6   210C           01629         call    tx_digit_in_w
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 39


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01630 
                      01631 
01D7                  01632 pri_10000:
Message[305]: Using default destination of 1 (file).
01D7   0A84           01633         incf    FSR
01D8   1E5A           01634         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01D9   29DD           01635         goto    pri_c
01DA   0880           01636         tstf    INDF
01DB   1903 29E0      01637         bz              pri_1000
01DD                  01638 pri_c:
01DD   125A           01639         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01DE   0800           01640         movfw   INDF
01DF   210C           01641         call    tx_digit_in_w
                      01642 
                      01643 
01E0                  01644 pri_1000:
Message[305]: Using default destination of 1 (file).
01E0   0A84           01645         incf    FSR
01E1   1E5A           01646         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01E2   29E6           01647         goto    pri_d
01E3   0880           01648         tstf    INDF
01E4   1903 29EB      01649         bz              pri_100
01E6                  01650 pri_d:
01E6   125A           01651         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01E7   0800           01652         movfw   INDF
01E8   210C           01653         call    tx_digit_in_w
                      01654 
01E9   302C           01655         movlw   ','
01EA   210D           01656         call    tx_w
                      01657 
                      01658 
01EB                  01659 pri_100:
Message[305]: Using default destination of 1 (file).
01EB   0A84           01660         incf    FSR
01EC   1E5A           01661         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01ED   29F1           01662         goto    pri_e
01EE   0880           01663         tstf    INDF
01EF   1903 29F4      01664         bz              pri_10
01F1                  01665 pri_e:
01F1   125A           01666         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
01F2   0800           01667         movfw   INDF
01F3   210C           01668         call    tx_digit_in_w
                      01669 
                      01670 
01F4                  01671 pri_10:
Message[305]: Using default destination of 1 (file).
01F4   0A84           01672         incf    FSR
01F5   1E5A           01673         btfss   print_flags, ZERO_SUPPRESSION_FLAG
01F6   29FA           01674         goto    pri_f
01F7   0880           01675         tstf    INDF
01F8   1903 29FD      01676         bz              pri_1
01FA                  01677 pri_f:
01FA   125A           01678         bcf             print_flags,    ZERO_SUPPRESSION_FLAG
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 40


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

01FB   0800           01679         movfw   INDF
01FC   210C           01680         call    tx_digit_in_w
                      01681 
01FD                  01682 pri_1:
Message[305]: Using default destination of 1 (file).
01FD   0A84           01683         incf    FSR
01FE   0800           01684         movfw   INDF
01FF   210C           01685         call    tx_digit_in_w
                      01686 
0200                  01687 pri_space:
                      01688 ; space
0200   3020           01689         movlw   ' '
0201   210D           01690         call    tx_w    
                      01691 
                      01692 ; Hz
0202   3048           01693         movlw   'H'
0203   210D           01694         call    tx_w
                      01695 
0204   307A           01696         movlw   'z'
0205   210D           01697         call    tx_w
                      01698 
                      01699 ; print 2 spaces
0206   3020           01700         movlw   ' '
0207   210D           01701         call    tx_w    
                      01702 
0208   3020           01703         movlw   ' '
0209   210D           01704         call    tx_w    
                      01705 
                      01706 #endif ; RS232_PRINT_FIELD_2
                      01707 
                      01708 #endif  ; RS232_OUT
                      01709 
                      01710     ; Display routine for frequencies up to "99.99 MHz" (theoretical):
                      01711           ; (do NOT insert the decimal point yet, 
                      01712           ;   it would disturb the blanking of LEADING zeroes )
020A   3040           01713           movlw digits                  ; find the first significant digit..
020B   0084           01714           movwf FSR                     ; .. by stepping over leading zeroes
020C   0880           01715           tstf  INDF                    ; INDF = *(FSR) in "C" syntax, FSR points to 'digits'
020D   1D03 2A1F      01716           bnz   displ_MHz               ; 10-MHz-digit non-zero, show frequency in MHz
020F   0A84           01717           incf  FSR  ,  f               ; otherwise skip 1st digit (the 10-MHz place)
0210   0880           01718           tstf  INDF
0211   1D03 2A1F      01719           bnz   displ_MHz               ; 1-MHz-digit non-zero, show frequency in MHz
0213   0A84           01720           incf  FSR  ,  f               ; otherwise skip 2nd digit (the 1-MHz place)
0214   0880           01721           tstf  INDF
0215   1D03 2A1C      01722           bnz   displ_kHz               ; 100-kHz-digit non-zero, show frequency in kHz (XXX.X)
0217   0A84           01723           incf  FSR  ,  f               ; otherwise skip 3rd digit (the 100-kHz place)
0218   0880           01724           tstf  INDF
0219   1D03 2A1C      01725           bnz   displ_kHz               ; 10-kHz-digit non-zero, show frequency in kHz  (XX.XX)
021B   0A84           01726           incf  FSR  ,  f               ; Otherwise show digits 5,6,7,8 (there are EIGHT digits) 
                      01727                                         ; show all these frequencies with flashing kHz-point (X.XXX)
                      01728 
021C                  01729 displ_kHz:   ; insert a BLINKING POINT to indicate the kilohertz-digit
                      01730 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 41


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01731 #ifndef RS232_OUT
                      01732           btfsc blinker, 0  ; check the blink flag (bit 0) for the kHz-point
                      01733 #endif
                      01734 ; RS232_OUT
                      01735 ; in RS232_OUT we always have a dot if kHz (non blinking).
021C   17C4           01736           bsf digit_4, 7    ; set the decimal point indicating the frequency in kHz .
                      01737                         
021D   14DA           01738                 bsf     print_flags, KILOHERTZ_FLAG
                      01739 
021E   2A21           01740           goto  display
                      01741 
021F                  01742 displ_MHz:   ; insert a BLINKING POINT to indicate the kilohertz-digit
021F   17C1           01743           bsf   digit_1, 7  ; set the decimal point indicating the frequency in MHz .
                      01744          
0220   10DA           01745                 bcf     print_flags,    KILOHERTZ_FLAG
                      01746 
0221                  01747 display:  ; Show the FIVE digits beginning at INDF = *(FSR) on the LED display...
0221   0800           01748           movfw  INDF                   ; convert the four digits to
0222   2083           01749           call   conv_char0             ; LED display data
0223   0A84           01750           incf   FSR  ,  f              ; increment pointer to next digit
0224   0800           01751           movfw  INDF                   ; w = *(FSR)
0225   2086           01752           call   conv_char1             ; second visible digit
0226   0A84           01753           incf   FSR  ,  f
0227   0800           01754           movfw  INDF
0228   2089           01755           call   conv_char2             ; third visible digit
0229   0A84           01756           incf   FSR  ,  f
022A   0800           01757           movfw  INDF
022B   208C           01758           call   conv_char3             ; fourth visible digit
022C   0A84           01759           incf   FSR  ,  f
022D   0800           01760           movfw  INDF
022E   288F           01761           goto   conv_char4             ; convert fifth  visible digit AND RETURN
                      01762 ; end of routine "CvtAndDisplayFreq"
                      01763 
                      01764 
                      01765 ;--------------------------------------------------------------------------
                      01766 ; main entry point
                      01767 ;--------------------------------------------------------------------------
                      01768 
022F                  01769 MainInit:
                      01770 
                      01771 #IF 0   ; Test some math macros ?
                      01772           clrf  freq2_hi
                      01773           clrf  freq2_mh
                      01774           clrf  freq2_ml
                      01775           movlw .100
                      01776           movwf freq2_lo
                      01777           neg32 freq2                  ; -100 = 0xFFFFFF9C
                      01778 #ENDIF  ; Test !
                      01779 
                      01780 
022F   3000           01781           movlw PORT_A_IO               ; initialise port A
                      01782           errorlevel -302 ; Turn off banking message for the next few instructions..
0230   1683           01783           bsf   STATUS, RP0            ;! setting RP0 enables access to TRIS regs
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 42


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0231   0085           01784           movwf PORTA                  ;! looks like PORTA but is in fact TRISA 
0232   1283           01785           bcf   STATUS, RP0            ;! clearing RP0 enables access to PORTs
0233   0185           01786           clrf PORTA
                      01787 
0234   3000           01788           movlw PORT_B_IO               ; initialise port B
0235   1683           01789           bsf   STATUS, RP0            ;! setting RP0 enables access to TRIS regs
0236   0086           01790           movwf PORTB                  ;! looks like PORTB but is in fact TRISB
0237   1283           01791           bcf   STATUS, RP0            ;! clearing RP0 enables access to PORTs
                      01792           errorlevel +302 ; Enable banking message again
0238   0186           01793           clrf  PORTB
                      01794 
0239   01CE           01795           clrf disp_index               ; initialise display index and
023A   01CF           01796           clrf disp_timer               ; display multiplex timer
                      01797 
023B   3013           01798           movlw BLANK                   ; blank character as dummy ...
023C   00C8           01799           movwf digit_8                 ; for the lowest frequency display range
                      01800 
023D   3014           01801           movlw TEST                    ; test all LED segments
023E   2083           01802           call  conv_char0
023F   3014           01803           movlw TEST
0240   2086           01804           call  conv_char1
0241   3014           01805           movlw TEST
0242   2089           01806           call  conv_char2
0243   3014           01807           movlw TEST
0244   208C           01808           call  conv_char3
0245   3014           01809           movlw TEST
0246   208F           01810           call  conv_char4
                      01811 
                      01812 
0247   3027           01813           movlw PSC_DIV_BY_256          ; let the prescaler divide by 256 while testing..
0248   2068           01814           call  SetPrescaler            ; safely write <W> into option register
                      01815 
                      01816 #if(DEBUG==0)
                      01817           ; Do a LAMP TEST for half a second, including all decimal points :
0249   3061           01818           movlw (LAMPTEST_LOOPS)>>8     ; high byte for 0.5 second lamp test
024A   00AD           01819           movwf gatecnt_hi
024B   30A8           01820           movlw (LAMPTEST_LOOPS)&0ffh   ; low byte for 0.5 second lamp test
024C   00AE           01821           movwf gatecnt_lo
024D   20C4           01822           call count_pulses             ; some delay to show the test pattern
                      01823 #endif ; not DEBUG
                      01824 
                      01825 
024E                  01826 MainRestart:  ; Here we "restart" the counter after exiting from programming mode :
024E   01D2           01827           clrf   psave_timer              ; clear timer for power-save mode (no immediate power-down)
024F   01D4           01828           clrf   psave_flags              ; clear all power-saving flags (PSFLAG_ACTIVE, etc)
0250   3038           01829           movlw  foffs                    ; load destination address for reading from EEPROM...
0251   0084           01830           movwf  FSR                      ; ..into the PIC's pointer register
0252   3000           01831           movlw  EEPROM_ADR_FREQ_OFFSET+0 ; load the EEPROM-internal address offset (=source index)
0253   20BA           01832           call   EEPROM_Read4Byte         ; read from EEPROM:    foffs..foffs+4 := EEPROM[W]
0254   3055           01833           movlw  options                  ; another destination address for reading from EEPROM..
0255   0084           01834           movwf  FSR                      ;
0256   3020           01835           movlw  EEPROM_ADR_OPTIONS       ; load EEPROM-internal offset of "options"-byte
0257   20B0           01836           call   EEPROM_ReadByte          ; read single byte from EEPROM: options := EEEPROM[W]
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 43


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01837 #if(DEBUG==1)
                      01838           bsf    OPT_PWRSAVE ; enable power-save mode for debugger/simulator   
                      01839 #endif ; DEBUG
                      01840 
                      01841           ; Blank the display until 1st measurement is available :
0258   2096           01842           call  ClearDisplay
                      01843 
                      01844 
                      01845 ;--------------------------------------------------------------------------
                      01846 ; main loop :  Preparation, auto ranging, measurement, conversion, display
                      01847 ;--------------------------------------------------------------------------
                      01848 
0259                  01849 MainLoop:
                      01850 
                      01851           ; re-initialise ports
                      01852           ; ex: tris  PORTA;   tris  PORTB
                      01853           errorlevel -302 ; Turn off banking message for the next few instructions..
0259   1683           01854           bsf   STATUS, RP0            ;! setting RP0 enables access to TRIS regs
025A   3000           01855           movlw PORT_A_IO              ;! 
025B   0085           01856           movwf PORTA                  ;! looks like PORTA but is in fact TRISA 
025C   3000           01857           movlw PORT_B_IO              ;!
025D   0086           01858           movwf PORTB                  ;! looks like PORTB but is in fact TRISB
025E   1283           01859           bcf   STATUS, RP0            ;! clearing RP0 enables access to PORTs
025F   0064           01860           clrwdt                        ; configure TMR0... but clear watchdog timer first
0260   3020           01861           movlw b'100000'               ; value for OPTION reg: edge - low-to-high transition, 
                      01862                                         ;  + prescaler assigned to Timer 0, 1:2
0261   1683           01863           bsf   STATUS, RP0            ;! setting RP0 enables access to OPTION reg
                      01864                ; option register is in bank1. i know. thanks for the warning.
0262   0081           01865           movwf OPTION_REG             ;! ex: "option" command (yucc)
0263   1283           01866           bcf   STATUS, RP0            ;! clearing RP0 for normal register access
                      01867           errorlevel +302 ; Enable banking message again
                      01868 
                      01869 #ifdef BAUDRATE_TEST
                      01870 test1:
                      01871         movlw   'A'
                      01872         call    tx_w
                      01873 
                      01874         call    bit_delay
                      01875         call    bit_delay
                      01876         call    bit_delay
                      01877         call    bit_delay
                      01878         call    bit_delay
                      01879         call    bit_delay
                      01880         call    bit_delay
                      01881         call    bit_delay
                      01882         call    bit_delay
                      01883         call    bit_delay
                      01884         call    bit_delay
                      01885         call    bit_delay
                      01886         call    bit_delay
                      01887         call    bit_delay
                      01888         call    bit_delay
                      01889         call    bit_delay
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 44


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01890         call    bit_delay
                      01891         call    bit_delay
                      01892         goto    test1
                      01893 #endif
                      01894 ; BAUDRATE_TEST
                      01895 
                      01896           ; First do a 'range-detection measurement' to find
                      01897           ; a suitable prescaler ratio. Worst-case-estimation:
                      01898           ; 50 MHz at the input of the async TIMER 0 prescaler 
                      01899           ; requires a prescaler ratio of 64 because 
                      01900           ; the synchron counter in TIMER 0 accepts a maximum
                      01901           ; frequency of f_osc / 4, here: max. 1 MHz.
                      01902           ; The theoretic maximum frequency is 64 MHz then, which
                      01903           ; was almost reached when tested with a PIC 16F628 .
                      01904           ; The range-detection interval is somewhere near 1/30 seconds (see RANGE_DET_LOOPS),
                      01905           ; so frequencies below 30*64 = 1920 Hz are not detectable at this step.
  00000682            01906 RANGE_DET_LOOPS equ  CLOCK/(.30*CYCLES) ; number of gate-time loops to detect the MEASURING RANGE
                      01907                                         ; (which is required to find a good prescaler value) 
0264   3006           01908           movlw (RANGE_DET_LOOPS)>>8    ; high byte for RANGE DETECTION loop counter
0265   00AD           01909           movwf gatecnt_hi
0266   3082           01910           movlw (RANGE_DET_LOOPS)&0ffh  ; low byte for RANGE DETECTION loop counter
0267   00AE           01911           movwf gatecnt_lo
0268   3025           01912           movlw PSC_DIV_BY_64           ; let the prescaler divide by 64 while testing..
0269   2068           01913           call  SetPrescaler            ; safely write <W> into option register
                      01914 
026A   20C4           01915           call count_pulses             ; count pulses for the range detection interval (1/16 sec)
                      01916            ; The result will be placed in freq_lo,freq_ml,freq_mh,freq_hi (32 bit)
                      01917            ; but the max count at 64 MHz input, 1/30 sec gate time, and prescaler=64 will be :
                      01918            ;   64MHz / (30 * 64) = 33333 pulses, so only 16 bits in the counter
                      01919            ;  are required here (call them "testcount", f_in = testcount * 30*64) .
                      01920            ; The frequency resolution of this coarse measurement is 64*16 Hz = roughly 1 kHz.
                      01921            ; (for that reason it's not suited for "wake-up from power-save on frequency-change")
                      01922 
                      01923 #if 0  ; TEST auto ranging
                      01924           movlw (.8500)>>8   ; high byte of counted pulses
                      01925           movwf freq_ml
                      01926           movlw (.8500)&0ffh ; low byte of counted pulses
                      01927           movwf freq_lo
                      01928 #endif ; end TEST
                      01929 
                      01930           ; Load the default (soft-)counters for the GATE TIME.
                      01931           ; Most measuring ranges use a 1/4 second gate time !
026B   3030           01932           movlw (GATE_TIME_LOOPS/4)>>8   ; high byte of gate time
026C   00AD           01933           movwf gatecnt_hi
026D   30D4           01934           movlw (GATE_TIME_LOOPS/4)&0ffh ; low byte of gate time
026E   00AE           01935           movwf gatecnt_lo
                      01936 
                      01937 
                      01938           ; Increment the "blinker" once every 0.25 seconds.
                      01939           ;  (if the gate time is longer, flashing will be slower, that's acceptable)
026F   0AD1           01940           incf  blinker, f
0270   0AD2           01941           incf  psave_timer, f     ; increment the power-save timer every 0.25 seconds too (checked some
                            where else)
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 45


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      01942 
                      01943           ; Look at the range-detection count ("testcount") 
                      01944           ; and decide which measuring range to use, beginning with the highest frequency range
                      01945 #if (DISP_VARIANT==1)
                      01946            ; Ranges FOR VARIANT 1,  4 MHz CRYSTAL (low-power variant, less resolution at HF !)
                      01947            ; Rng  testcount    f_in            prescaler gate_time   display,   resolution
                      01948            ; (1)     0..6         0.. 11.5 kHz   1       1   second  X.XXXkHz,  0.001kHz (4 digits only)
                      01949            ; (2)     7..54         ..103.6 kHz   1       1/2 second  XX.XXXkHz, 0.002kHz (last digit ste
                            ps by 2) 
                      01950            ; (3)    55..511        ..981.1 kHz   1       1/4 second  XXX.XXkHz, 0.004kHz (last digit ste
                            ps by 1)
                      01951            ; (4)   512..1023       ..  1.9 MHz   2       1/4 second  XXX.XXkHz, 0.008kHz (last digit ste
                            ps by 1)
                      01952            ; (5)  1024..2047       ..  3.9 MHz   4       1/4 second  X.XXXXMHz, 0.016kHz (last digit ste
                            ps by 1)
                      01953            ; (6)  2048..4095       ..  7.9 MHz   8       1/4 second  X.XXXXMHz, 0.032kHz (last digit ste
                            ps by 1)
                      01954            ; (7)  4096..8191      ... 15.7 MHz  16       1/4 second  X.XXXXMHz, 0.064kHz (last digit ste
                            ps by 1)
                      01955            ; (8)  8192..16383     ... 31.4 MHz  32       1/4 second  X.XXXXMHz, 0.128kHz (last digit ste
                            ps by 1 or 2)
                      01956            ; (9) 16384..33300     ... 63.9 MHz  64       1/4 second  XX.XXXMHz, 0.256kHz (last digit ste
                            ps by 1)
                      01957 
                      01958           movfw freq_ml        ; first look at bits 15..8 of the 'test count' result
                      01959           andlw b'11000000'    ; any of bits 15..14 set (>=16384) -> no Z flag -> range 9
                      01960           btfss STATUS,Z       ; skip next instruction if ZERO-flag set (!)
                      01961           goto  Range9         ; far jump to range 9
                      01962           btfsc freq_ml,5      ; bit 13 set (>=8192) ->  range 8
                      01963           goto  Range8
                      01964           btfsc freq_ml,4      ; bit 12 set (>=4096) ->  range 7
                      01965           goto  Range7
                      01966           btfsc freq_ml,3      ; bit 11 set (>=2048) ->  range 6
                      01967           goto  Range6         
                      01968           btfsc freq_ml,2      ; bit 10 set (>=1024) ->  range 5 
                      01969           goto  Range5         
                      01970           btfsc freq_ml,1      ; bit 9 set (>=512)   ->  range 4 
                      01971           goto  Range4
                      01972           btfsc freq_ml,0      ; bit 8 set (>=256) -> no Z flag  -> range 3
                      01973           goto  Range3
                      01974           movfw freq_lo        ; now look at bits 7..0 only ..
                      01975           sublw .54            ; subtract #54 - W register -> C=0 if result negative
                      01976           btfss STATUS,C       ; skip next instruction if C=1 (#54-W >= 0)
                      01977           goto  Range3         ; freq > 100kHz -> also range 3
                      01978           movfw freq_lo        ; look at bits 7..0 again ..
                      01979           sublw .5             ; subtract #5 - W register -> C=0 if result negative
                      01980           btfss STATUS,C       ; skip next instruction if C=1 
                      01981           goto  Range2         ; freq > 10kHz -> range 2
                      01982           goto  Range1         ; otherwise range 1
                      01983 #endif ; end of specific range-switching for  DISPLAY VARIANT #1
                      01984 
                      01985 #if (DISP_VARIANT==2) || (DISP_VARIANT==3)
                      01986            ; Ranges FOR VARIANT 2+3,  20 MHz CRYSTAL (draws more power, but gives better resolution at H
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 46


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                            F )
                      01987            ; Even if PIC clocked with 20MHz, keep the input of TIMER0 below 4(!) MHz .
                      01988            ; Rng  testcount    f_in            prescaler gate_time   display,   resolution
                      01989            ; (1)     0..6         0.. 11.5 kHz   1       1   second  X.XXXkHz,  0.001kHz (4 digits only)
                      01990            ; (2)     7..54         ..103.6 kHz   1       1/2 second  XX.XXXkHz, 0.002kHz (last digit ste
                            ps by 2) 
                      01991            ; (3)    44..2047       ..  3.9 MHz   1       1/4 second  X.XXXXMHz,    4 Hz  (last digit ste
                            ps by 1)
                      01992            ; (4)  2048..4095       ..  7.9 MHz   2       1/4 second  X.XXXXMHz,    8 Hz  (last digit ste
                            ps by 1)
                      01993            ; (5)  4096..8191      ... 15.7 MHz   4       1/4 second  X.XXXXMHz,   16 Hz  (last digit ste
                            ps by 1)
                      01994            ; (6)  8192..16383     ... 31.4 MHz   8       1/4 second  X.XXXXMHz,   32 Hz  (last digit ste
                            ps by 1 or 2)
                      01995            ; (7) 16384..33330     ... 63.9 MHz  16       1/4 second  XX.XXXMHz,   64 Hz  (last digit ste
                            ps by 1)
0271   0832           01996           movfw freq_ml        ; first look at bits 15..8 of the 'test count' result
0272   39C0           01997           andlw b'11000000'    ; any of bits 15..14 set (>=16384) -> no Z flag -> range 7
0273   1D03           01998           btfss STATUS,Z       ; skip next instruction if ZERO-flag set (!)
0274   2AAB           01999           goto  Range7         ; far jump to range 7
0275   1AB2           02000           btfsc freq_ml,5      ; bit 13 set (>=8192) ->  range 6
0276   2AA7           02001           goto  Range6
0277   1A32           02002           btfsc freq_ml,4      ; bit 12 set (>=4096) ->  range 5
0278   2AA3           02003           goto  Range5
0279   19B2           02004           btfsc freq_ml,3      ; bit 11 set (>=2048) ->  range 4
027A   2A9F           02005           goto  Range4
027B   1932           02006           btfsc freq_ml,2      ; bit 10 set (>=1024) ->  range 3
027C   2A9C           02007           goto  Range3
027D   18B2           02008           btfsc freq_ml,1      ; bit 9 set (>=512)   ->  range 3
027E   2A9C           02009           goto  Range3
027F   1832           02010           btfsc freq_ml,0      ; bit 8 set (>=256) -> no Z flag  -> range 3
0280   2A9C           02011           goto  Range3
0281   0833           02012           movfw freq_lo        ; now look at bits 7..0 only ..
0282   3C36           02013           sublw .54            ; subtract #54 - W register -> C=0 if result negative
0283   1C03           02014           btfss STATUS,C       ; skip next instruction if C=1 (#54-W >= 0)
0284   2A9C           02015           goto  Range3         ; freq > 100kHz -> also range 3
0285   0833           02016           movfw freq_lo        ; look at bits 7..0 again ..
0286   3C05           02017           sublw .5             ; subtract #5 - W register -> C=0 if result negative
0287   1C03           02018           btfss STATUS,C       ; skip next instruction if C=1 
0288   2A94           02019           goto  Range2         ; freq > 10kHz -> range 2
0289   2A8A           02020           goto  Range1         ; otherwise range 1 (lowest frequencies)
                      02021 #endif ; end of specific range-switching for  DISPLAY VARIANT #2
                      02022 
028A                  02023 Range1:   ; Range 1:  async prescaler off, 1 second gate time for very low frequencies  :
028A   206D           02024           call  PrescalerOff             ; turn hardware prescaler off
028B   0AD2           02025           incf  psave_timer, f           ; increment power-save timer three more times 
028C   0AD2           02026           incf  psave_timer, f           ;  (1 sec-gate instead of 0.25)  
028D   0AD2           02027           incf  psave_timer, f
                      02028           ; Load the GATE TIMER (as count of loops) for this measuring range.
028E   30C3           02029           movlw (GATE_TIME_LOOPS)>>8     ; high byte for 1 second gate time
028F   00AD           02030           movwf gatecnt_hi
0290   3050           02031           movlw (GATE_TIME_LOOPS)&0ffh   ; low byte for 1 second gate time
0291   00AE           02032           movwf gatecnt_lo
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 47


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02033           ; Load the count of "left shifts" to compensate gate time + prescaler :
0292   3000           02034           movlw 0   ; no need to multiply with prescaler 1:1 and 1-sec gate time
0293   2AAF           02035           goto  GoMeasure              
                      02036 
0294                  02037 Range2:   ; Range 2:  async prescaler off, 1/2 second gate time for quite low frequencies  :
0294   206D           02038           call  PrescalerOff             ; turn hardware prescaler off
0295   0AD2           02039           incf  psave_timer, f           ; increment power-save timer one more time (0.5 sec-gate instea
                            d of 0.25)
                      02040           ; Load the GATE TIMER (as count of loops) for this measuring range.
0296   3061           02041           movlw (GATE_TIME_LOOPS/2)>>8   ; high byte for 1/2 second gate time
0297   00AD           02042           movwf gatecnt_hi
0298   30A8           02043           movlw (GATE_TIME_LOOPS/2)&0ffh ; low byte for 1/2 second gate time
0299   00AE           02044           movwf gatecnt_lo
                      02045           ; Load the count of "left shifts" to compensate gate time + prescaler :
029A   3001           02046           movlw 1   ; multiply by 2 (=2^1) later to compensate gate time (1/2 s)
029B   2AAF           02047           goto  GoMeasure              
                      02048                    
029C                  02049 Range3:   ; Range 3: async prescaler off, gate time = default (1/4 sec) :
029C   206D           02050           call  PrescalerOff             ; turn hardware prescaler off
029D   3002           02051           movlw 2   ; multiply by 4 (=2^2) later to compensate gate time (1/4 s)
029E   2AAF           02052           goto  GoMeasure              
                      02053 
029F                  02054 Range4:   ; Range 4: prescaler divide by 2 , gate time = default (1/4 sec) :
029F   3020           02055           movlw PSC_DIV_BY_2            ; let the prescaler divide by 2 while MEASURING...
02A0   2068           02056           call  SetPrescaler            ; safely write <W> into option register
02A1   3003           02057           movlw 3   ; multiply by 8 (=2^3) later to compensate prescaling (1:2) * gate time (1/4 s)
02A2   2AAF           02058           goto  GoMeasure              
                      02059 
02A3                  02060 Range5:   ; Range 5: prescaler divide by 4 , gate time = default (1/4 sec) :
02A3   3021           02061           movlw PSC_DIV_BY_4            ; let the prescaler divide by 2 while MEASURING...
02A4   2068           02062           call  SetPrescaler            ; safely write <W> into option register
02A5   3004           02063           movlw 4   ; multiply by 16 (=2^4) later to compensate prescaling (1:4) * gate time (1/4 s)
02A6   2AAF           02064           goto  GoMeasure              
                      02065 
02A7                  02066 Range6:   ; Range 6: prescaler divide by 8 , gate time = default (1/4 sec) :
02A7   3022           02067           movlw PSC_DIV_BY_8            ; let the prescaler divide by 2 while MEASURING...
02A8   2068           02068           call  SetPrescaler            ; safely write <W> into option register
02A9   3005           02069           movlw 5   ; multiply by 32 (=2^5) later to compensate prescaling (1:8) * gate time (1/4 s)
02AA   2AAF           02070           goto  GoMeasure              
                      02071 
02AB                  02072 Range7:   ; Range 7: prescaler divide by 16 , gate time = default (1/4 sec) :
02AB   3023           02073           movlw PSC_DIV_BY_16           ; let the prescaler divide by 2 while MEASURING...
02AC   2068           02074           call  SetPrescaler            ; safely write <W> into option register
02AD   3006           02075           movlw 6   ; multiply by 64 (=2^6) later to compensate prescaling (1:16) * gate time (1/4 s)
02AE   2AAF           02076           goto  GoMeasure              
                      02077 
                      02078 #if (DISP_VARIANT==1)   ; Ranges 8 + 9  are only needed for VARIANT 1  with 4-MHz crystal :
                      02079 Range8:   ; Range 8: prescaler divide by 32 , gate time = default (1/4 sec) :
                      02080           movlw PSC_DIV_BY_32           ; let the prescaler divide by 2 while MEASURING...
                      02081           call  SetPrescaler            ; safely write <W> into option register
                      02082           movlw 7   ; multiply by 128 (=2^7) later to compensate prescaling (1:32) * gate time (1/4 s)
                      02083           goto  GoMeasure              
                      02084 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 48


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02085 Range9:   ; Range 9: prescaler divide by 64 , gate time = default (1/4 sec) :
                      02086           movlw PSC_DIV_BY_64           ; let the prescaler divide by 2 while MEASURING...
                      02087           call  SetPrescaler            ; safely write <W> into option register
                      02088           movlw 8   ; multiply by 256 (=2^8) later to compensate prescaling (1:64) * gate time (1/4 s)
                      02089           goto  GoMeasure
                      02090 #endif  ; (DISP_VARIANT==1)
                      02091 
                      02092 
02AF   00D0           02093 GoMeasure: movwf adjust_shifts         ; save the number of "arithmetic left shifts" for later
02B0   20C4           02094           call count_pulses            ; count pulses for 1, 1/2, or 1/8 s .
                      02095           ; Result in freq_lo,freq_ml,freq_mh,freq_hi (32 bit) now, 
                      02096           ; NOT adjusted for the gate-time or prescaler division ratio yet.
                      02097 
                      02098 
                      02099           ;----------------- Power-saving mode ------------------------------------
                      02100           ; Power-saving mode enabled or about to be activated ?
02B1   1C55           02101           btfss  OPT_PWRSAVE           ; Power-save mode enabled (from config) ?
02B2   2AE0           02102           goto   PsNotBlanked
                      02103           ; Arrived here: power-saving is ENABLED through the config,
                      02104           ;               but not necessarily ACTIVE at the moment .
                      02105           ; If power-save is already active, clear the display (may have 'flashed up')
02B3   1854           02106           btfsc  PSFLAG_ACTIVE         ; if power-save already 'ACTIVE'..
02B4   2096           02107           call   ClearDisplay          ; then clear the display (latch)
                      02108           ; Next: Check if the frequency has changed significantly
                      02109           ; since the last 'reload' of the power-save timer.
                      02110           ; To keep things simple, only look at the LOW BYTES of the 
                      02111           ; 'current' and the 'old' frequency reading at this stage
                      02112           ; (BEFORE multiplying the result with two power adjust_shifts) .
                      02113           ; 'psave_freq_lo' is an "old" reading; 'freq_lo' the current frequency.
                      02114           ; Both are UNSIGNED 8-bit values !
02B5   0833           02115           movfw freq_lo                ; get low-byte of current frequency
02B6   0253           02116           subwf psave_freq_lo, w       ; W := freq_lo - psave_freq_lo
                      02117           ; Make the difference (new minus old frequency in W) positive :
02B7   00AF           02118           movwf bTemp                  ; bTemp := (freq_lo - psave_freq_lo)  
02B8   1FAF           02119           btfss bTemp,7                ; check the sign-bit (=MSB)
02B9   2ABC           02120           goto  PsDiffPos              ; difference already posivite, else :
02BA   09AF           02121           comf  bTemp,f                ; bTemp := ~bTemp (for example, 0xFF -> 0x00)
02BB   0AAF           02122           incf  bTemp,f                ; add one for two's complement
02BC                  02123 PsDiffPos:; ; Arrived here: difference made positive, i.e.  bTemp = abs(freq_lo - psave_freq_lo) .
                      02124           ; If the frequency-difference is 'quite high',
                      02125           ;   turn off the flag PSFLAG_ACTIVE  and clear the power-save-timer:
02BC   082F           02126           movfw bTemp                  ; W := abs(freq_lo - psave_freq_lo)
02BD   3C0A           02127           sublw PSAVE_MAX_DIFF         ; W := PSAVE_MAX_DIFF - W  ; C=0 if result negative (=large f-dif
                            f)
02BE   1803           02128           btfsc STATUS,C               ; skip next instruction if large frequency difference
02BF   2AC5           02129           goto  PsSmallDiff            ; 
02C0                  02130 PsLargeDiff: ; Arrived here: there's a LARGE difference between 'current' and 'old' frequency
02C0   1054           02131           bcf    PSFLAG_ACTIVE         ; Back to normal display mode
02C1   01D2           02132           clrf   psave_timer           ; restart 'power-save' activation timer (with display ON)
02C2   0833           02133           movfw  freq_lo               ; set 'current' frequency as new 'old' frequency...
02C3   00D3           02134           movwf  psave_freq_lo         ; for the next XX-second interval !
02C4   2AE0           02135           goto   PsNotBlanked
02C5                  02136 PsSmallDiff: ; Arrived here: there's only a SMALL difference between 'current' and 'old' frequency .
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 49


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

02C5   1854           02137           btfsc  PSFLAG_ACTIVE         ; power-save already 'ACTIVE' ?
02C6   2AD1           02138           goto   PsActive              ; yes, already active -> check for flash-up
                      02139           ; Check the power-save timer; it may be time to turn the display OFF now :
02C7   0852           02140           movfw  psave_timer           ; if(psave_timer > PSAVE_DELAY_TIME ) ...
02C8   3C3C           02141           sublw  PSAVE_DELAY_TIME      ; subtract #PSAVE_DELAY_TIME - W -> C=0 if result negative
02C9   1803           02142           btfsc  STATUS,C              ; skip next instruction if carry=0 (PSAVE_DELAY_TIME-W < 0)
02CA   2ADA           02143           goto   PsNoTimeout           ; psave_timer still low, no 'timeout' yet !
                      02144           ; Arrived here: Display was on, but almost no change in frequency -> enter power-saving mode
02CB   300D           02145           movlw  PSAVE_FLASHUP_TIME-1  ; let display flash up once before turning off
02CC   00D2           02146           movwf  psave_timer           ; ... to avoid overflow when incrementing it later
02CD   1454           02147           bsf    PSFLAG_ACTIVE         ; set the flag 'power-save ACTIVE' to blank the display
02CE   0833           02148           movfw  freq_lo               ; save low-byte of frequency when ENTERING power-save mode
02CF   00D3           02149           movwf  psave_freq_lo
02D0   2ADC           02150           goto   PsSleep               ; sleep for the first 600-millisecond-interval now
                      02151 
02D1                  02152 PsActive: ; Here if power-saving mode already active .
                      02153           ; Check it it's time to let the display flash up for a short time 
                      02154           ; to show the operator we're still alive !
02D1   0852           02155           movfw  psave_timer           ; if(psave_timer > PSAVE_DELAY_TIME ) ...
02D2   3C0E           02156           sublw  PSAVE_FLASHUP_TIME    ; subtract #PSAVE_FLASHUP_TIME - W -> C=0 if result negative
02D3   1803           02157           btfsc  STATUS,C              ; skip next instruction if (PSAVE_FLASHUP_TIME-psave_timer) < 0
02D4   2ADC           02158           goto   PsSleep               ; psave_timer still low, don't 'flash up' yet !
02D5   01D2           02159 PsFlashUp: clrf  psave_timer           ; prepare timer for next period of darkness
02D6   0833           02160           movfw  freq_lo               ; avoid turning the display on ..
02D7   00D3           02161           movwf  psave_freq_lo         ;   .. if the VFO is only "slowly creeping"
02D8   01D2           02162           clrf   psave_timer           ; restart 'power-save' activation timer (with display OFF)
02D9   2AE0           02163           goto   PsNotBlanked          ; and let the display flash up for one gate interval
                      02164 
02DA                  02165 PsNoTimeout: ; small frequency difference, AND psave_timer still low..
                      02166           ; Already in "power-save"-mode or normal display ?
02DA   1C54           02167           btfss  PSFLAG_ACTIVE         ; check the flag 'power-save ACTIVE'
02DB   2AE0           02168           goto   PsNotBlanked          ; not set -> normal display (not blanked)
                      02169           ; Arrived here: 'Saving power', which means the display 
                      02170           ;   is blanked MOST of the time (but it may flash up every XX seconds
                      02171           ;   to show the operator we're still alive) .
02DC   2077           02172 PsSleep:  call   Sleep150ms            ; put CPU to sleep for ~500 milliseconds..
02DD   2077           02173           call   Sleep150ms
02DE   2077           02174           call   Sleep150ms
02DF   2B24           02175           goto   CheckProgMode         ; skip integer->BCD conversion (save power)
                      02176 
02E0                  02177 PsNotBlanked: ; Display is not blanked for power-saving mode at the moment.
                      02178           ; If this 'absolute difference' is quite large,
                      02179           ; clear the power-save timer to prevent turning off the display
                      02180           ; within the next XX seconds :
                      02181           ; Reload the power-save-timer if there was a significant change
                      02182           ; since the last comparison. 
                      02183 
                      02184 
                      02185 
02E0                  02186 PrepDisp: ; Prepare the frequency (32-bit 'unadjusted' integer) for display:
                      02187           ; Multiply freq by 2^adjust_shifts to adjust for the prescaling 
                      02188 
                      02189 ; WQS 2 frequency in Hz here
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 50


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02190 
                      02191           ; and the timing period .  The result will be a frequency in HERTZ, 32-bit integer.
                      02192 
                      02193           ; Note: the adjustment factor may be ONE which means no shift at all.
02E0   08D0           02194           tstf  adjust_shifts
02E1   1903 2AEA      02195           bz    NoAdjust   
02E3   1003           02196 Adjust:   clrc                          
02E4   0DB3           02197           rlf freq_lo , f 
02E5   0DB2           02198           rlf freq_ml , f
02E6   0DB1           02199           rlf freq_mh , f
02E7   0DB0           02200           rlf freq_hi , f
02E8   0BD0           02201           decfsz adjust_shifts, f
02E9   2AE3           02202           goto Adjust
02EA                  02203 NoAdjust:  
                      02204 
                      02205 ; WAS 3
                      02206 
                      02207           ; Check the result against under- and overflow.
                      02208           ; (There should be none if the frequency didn't change too rapidly
                      02209           ;  between the range-detection and the actual measurement )
02EA   0830           02210           movfw freq_hi                 ; underflow (freq = 0) ?
02EB   0431           02211           iorwf freq_mh,w
02EC   0432           02212           iorwf freq_ml,w
02ED   0433           02213           iorwf freq_lo,w
                      02214 
                      02215 #ifndef RS232_OUT
                      02216 ; WAS this causes print to skip
                      02217           bz freq_underflow             ; branch if yes
                      02218 #endif
                      02219 ; ! RS232_OUT
02EE   1BB0           02220           btfsc freq_hi,7               ; overflow (freq > 7FFfffffh) ?
02EF   2B33           02221           goto freq_overflow            ; branch if yes
                      02222 
                      02223 ; WAS 4
                      02224 ; freq in freq_hi, freq_mh, freq_ml, freq_lo ????
                      02225 ; 32 bit binary to BCD, display?
                      02226 
                      02227 
                      02228          ; Save the frequency value without offset for programming mode in 'freq2',
                      02229          ;   because 'freq' will be lost when splitting it into digits.
02F0   0830           02230           movfw freq_hi
02F1   00B4           02231           movwf freq2_hi
02F2   0831           02232           movfw freq_mh
02F3   00B5           02233           movwf freq2_mh
02F4   0832           02234           movfw freq_ml
02F5   00B6           02235           movwf freq2_ml
02F6   0833           02236           movfw freq_lo
02F7   00B7           02237           movwf freq2_lo
                      02238 
                      02239          ; Add the programmable frequency offset 
                      02240          ; (often used to add or subtract the intermediate frequency in superhet receivers)
                      02241           add32 freq, foffs             ; freq := freq+foffs;  32-bit
                          M 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 51


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

02F8   083B               M           movfw foffs+3                 ; add low byte        (bits 7...0)
02F9   07B3               M           addwf freq+3,f
                          M 
02FA   083A               M           movfw foffs+2                 ; add middle-low byte (bits 15..8)
                          M           addcwf freq+2
                          M 
  0000                    M           local add1,add2
                          M 
02FB   1C03 2B02          M           bnc add1                      ; branch if no carry set
                          M 
02FD   07B2               M           addwf freq+2 , f              ; add byte
                          M 
02FE   0AB2               M           incf freq+2 , f               ; add carry
02FF   1903               M           skpnz
0300   1403               M           setc
                          M 
0301   2B03               M           goto add2
                          M 
0302   07B2               M add1      addwf freq+2,f                ; add byte
                          M 
0303                      M add2
                          M 
0303   0839               M           movfw foffs+1                 ; add middle-high byte (bits 23...16)
                          M           addcwf freq+1
                          M 
  0000                    M           local add1,add2
                          M 
0304   1C03 2B0B          M           bnc add1                      ; branch if no carry set
                          M 
0306   07B1               M           addwf freq+1 , f              ; add byte
                          M 
0307   0AB1               M           incf freq+1 , f               ; add carry
0308   1903               M           skpnz
0309   1403               M           setc
                          M 
030A   2B0C               M           goto add2
                          M 
030B   07B1               M add1      addwf freq+1,f                ; add byte
                          M 
030C                      M add2
                          M 
030C   0838               M           movfw foffs+0                 ; add high byte       (bits 31...24) 
                          M           addcwf freq+0
                          M 
  0000                    M           local add1,add2
                          M 
030D   1C03 2B14          M           bnc add1                      ; branch if no carry set
                          M 
030F   07B0               M           addwf freq+0 , f              ; add byte
                          M 
0310   0AB0               M           incf freq+0 , f               ; add carry
0311   1903               M           skpnz
0312   1403               M           setc
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 52


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                          M 
0313   2B15               M           goto add2
                          M 
0314   07B0               M add1      addwf freq+0,f                ; add byte
                          M 
0315                      M add2
                          M 
                      02242 
                      02243          ; If the result is negative, make it posisive
0315   1FB0           02244           btfss freq_hi, 7              ; bit 7 of the most significant byte is the SIGN
0316   2B23           02245           goto  f_positive              ; skip the following MACRO if positive..
                      02246           neg32 freq                    ; freq := -freq  (32-bit)
  0000                    M        local neg_done
0317   09B0               M            comf  freq,   f           ; invert all 8 bits in high byte  
0318   09B1               M            comf  freq+1, f           ; invert all 8 bits in middle high byte  
0319   09B2               M            comf  freq+2, f           ; invert all 8 bits in middle low byte  
031A   09B3               M            comf  freq+3, f           ; invert all 8 bits in low byte  
                          M            ; Note at this point 0x000000 would have turned into 0xFFFFFFF .
                          M            ; Must add ONE to complete the TWO's COMPLIMENT calculation ( -0  = 0 ).
                          M            ; Note that "incf" affects only the Z flag but not the C flag .
031B   0FB3               M            incfsz freq+3, f          ; increment low byte        (bits 7...0)
031C   2B23               M            goto   neg_done           ; if incremented result NOT zero, we're through !
031D   0FB2               M            incfsz freq+2, f          ; increment middle low byte (bits 15...8)
031E   2B23               M            goto   neg_done           ; if incremented result NOT zero, ...
031F   0FB1               M            incfsz freq+1, f          ; increment middle high byte (bits 23...16)
0320   2B23               M            goto   neg_done           ; if ...
0321   0FB0               M            incfsz freq+0, f          ; increment high byte       (bits 31...24)
0322   2B23               M            goto   neg_done           ;
0323                      M neg_done
0323                  02247 f_positive:
0323   2142           02248           call  CvtAndDisplayFreq       ; Convert <freq> into BCD and show it on the display
                      02249 
0324                  02250 CheckProgMode:
                      02251           ; Arrived here, the frequency is still valid in 'freq2'
                      02252           ;   but not in 'freq'.  Poll the programming key,
                      02253           ;   maybe the user wants to save this value as the new
                      02254           ;   FREQUENCY OFFSET .
                      02255 
                      02256 #ifdef RS232_OUT
                      02257 ; no prog loop in RS232_OUT, no offset, just a frequency counter.
0324   2A59           02258                 goto    MainLoop
                      02259 #endif
                      02260 ; RS232_out     
                      02261 
                      02262 #if(DEBUG==0)
0325   1E85           02263           btfss   IOP_PROG_MODE        ; Button "program mode" pressed ?
0326   2BC7           02264           goto    EnterProgLoop        ;  Yes, enter programming mode !
                      02265 #endif ; not DEBUG
                      02266 
0327   2A59           02267           goto MainLoop                ; end of main loop
                      02268 
                      02269 
                      02270 ;--------------------------------------------------------------------------
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 53


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

                      02271 ; frequency underflow (frequency < 1Hz)
                      02272 ;--------------------------------------------------------------------------
                      02273 
0328                  02274 freq_underflow:
0328   3013           02275           movlw BLANK                   ; display underflow as "   0[0]"
0329   2083           02276           call conv_char0               
032A   3013           02277           movlw BLANK
032B   2086           02278           call conv_char1
032C   3013           02279           movlw BLANK
032D   2089           02280           call conv_char2
032E   3000           02281           movlw 0                       ; why not 'zero' in the last digit ?                   
032F   208C           02282           call conv_char3
0330   3013           02283           movlw BLANK
0331   208F           02284           call conv_char4               ; because the 5th digit is OPTIONAL !
                      02285 
0332   2B24           02286           goto CheckProgMode
                      02287 
                      02288 
                      02289 ;--------------------------------------------------------------------------
                      02290 ; frequency overflow (frequency > 50MHz)
                      02291 ;--------------------------------------------------------------------------
                      02292 
0333                  02293 freq_overflow:
0333   3013           02294           movlw  BLANK                   ; display overflow as "   E"
0334   2083           02295           call   conv_char0
0335   3013           02296           movlw  BLANK
0336   2086           02297           call   conv_char1
0337   3013           02298           movlw  BLANK
0338   2089           02299           call   conv_char2
0339   300E           02300           movlw  CHAR_E
033A   208C           02301           call   conv_char3
033B   3013           02302           movlw  BLANK
033C   208F           02303           call   conv_char4               ; Note that the 5th digit is OPTIONAL !
                      02304 
                      02305 
033D   2A59           02306           goto MainLoop   ; end of main loop
                      02307 
                      02308 
                      02309 
                      02310 ;--------------------------------------------------------------------------
                      02311 ; program loop :  
                      02312 ;  - show a simple menu to select ADD or SUBTRACT offset,
                      02313 ;  - save the frequency offset value permanently in DATA EEPROM,
                      02314 ;  - return to the main loop when done .
                      02315 ;--------------------------------------------------------------------------
                      02316 
033E                  02317 ProgModeDisplay   ; Subroutine to update the LED display in programming mode + delay
033E   3013           02318           movlw (PROGMODE_LOOPS)>>8     ; high byte for delay loops (usually 0.1 second)
033F   00AD           02319           movwf  gatecnt_hi
0340   3088           02320           movlw (PROGMODE_LOOPS)&0ffh   ; low byte for delay loops
0341   00AE           02321           movwf  gatecnt_lo
0342   28C4           02322           goto   count_pulses   ; update mux display + some delay + return
                      02323 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 54


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0343                  02324 PmDisp_Quit: ; show "quit" on first 4 digits (quit programming mode)
0343   3018           02325           movlw  CHAR_Q
0344   2083           02326           call   conv_char0
0345   3019           02327           movlw  CHAR_u
0346   2086           02328           call   conv_char1
0347   3012           02329           movlw  CHAR_i
0348   2089           02330           call   conv_char2
0349   301A           02331           movlw  CHAR_t
034A   208C           02332 PmDisp4:  call   conv_char3      ; for menu items with 4 characters
034B   3013           02333           movlw  BLANK
034C   208F           02334 PmDisp5:  call   conv_char4
034D   2B3E           02335           goto   ProgModeDisplay
                      02336 
034E                  02337 PmDisp_PSave: ; show "PSave" or "Pnorm", depending on power-save flag
034E   1C55           02338           btfss  OPT_PWRSAVE    ; Power-save mode active ?
034F   2B5A           02339           goto   PMD_NoPwSave   
0350   3015           02340           movlw  CHAR_P         ; if so, print "PSAVE"..
0351   2083           02341           call   conv_char0
0352   301B           02342           movlw  CHAR_S
0353   2086           02343           call   conv_char1
0354   300A           02344           movlw  CHAR_A
0355   2089           02345           call   conv_char2
0356   3022           02346           movlw  CHAR_V
0357   208C           02347           call   conv_char3
0358   300E           02348           movlw  CHAR_E
0359   2B4C           02349           goto   PmDisp5
035A                  02350 PMD_NoPwSave:                   ; else print "NoPSV"
035A   3021           02351           movlw  CHAR_N
035B   2083           02352           call   conv_char0
035C   3017           02353           movlw  CHAR_o
035D   2086           02354           call   conv_char1
035E   3015           02355           movlw  CHAR_P
035F   2089           02356           call   conv_char2
0360   301B           02357           movlw  CHAR_S
0361   208C           02358           call   conv_char3
0362   3022           02359           movlw  CHAR_V
0363   2B4C           02360           goto   PmDisp5
                      02361 
0364                  02362 PmDisp_Add:  ; show "Add " on first 4 digits (add frequency offset)
0364   300A           02363           movlw  CHAR_A
0365   2083           02364           call   conv_char0
0366   300D           02365           movlw  CHAR_d
0367   2086           02366           call   conv_char1
0368   300D           02367           movlw  CHAR_d
0369   2089           02368           call   conv_char2
036A   3013           02369           movlw  BLANK
036B   2B4A           02370           goto   PmDisp4
036C                  02371 PmDisp_Sub:  ; show "Sub " on first 4 digits (subtract frequency offset)
036C   301B           02372           movlw  CHAR_S
036D   2083           02373           call   conv_char0
036E   3019           02374           movlw  CHAR_u
036F   2086           02375           call   conv_char1
0370   300B           02376           movlw  CHAR_b
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 55


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

0371   2089           02377           call   conv_char2
0372   3013           02378           movlw  BLANK
0373   2B4A           02379           goto   PmDisp4
0374                  02380 PmDisp_Zero: ; show "Zero" on first 4 digits (set frequency offset to zero)
0374   301C           02381           movlw  CHAR_Z
0375   2083           02382           call   conv_char0
0376   300E           02383           movlw  CHAR_E
0377   2086           02384           call   conv_char1
0378   3016           02385           movlw  CHAR_r
0379   2089           02386           call   conv_char2
037A   3017           02387           movlw  CHAR_o
037B   2B4A           02388           goto   PmDisp4
037C                  02389 PmDisp_StIF: ; show "taBLE" on first 4 digits (select standard IF)
037C   301A           02390           movlw  CHAR_t
037D   2083           02391           call   conv_char0
037E   300A           02392           movlw  CHAR_A
037F   2086           02393           call   conv_char1
0380   300B           02394           movlw  CHAR_b
0381   2089           02395           call   conv_char2
0382   3020           02396           movlw  CHAR_L
0383   208C           02397           call   conv_char3
0384   300E           02398           movlw  CHAR_E
0385   208F           02399           call   conv_char4
0386   2B3E           02400           goto   ProgModeDisplay
0387                  02401 PmDisp_IF_1: ; show 1st standard IF from table
0387   3004           02402           movlw  EEPROM_ADR_STD_IF_TABLE + 4*0
0388   2B91           02403           goto   PmLoadFreq2
0389                  02404 PmDisp_IF_2: ; show 2nd standard IF from table
0389   3008           02405           movlw  EEPROM_ADR_STD_IF_TABLE + 4*1
038A   2B91           02406           goto   PmLoadFreq2
038B                  02407 PmDisp_IF_3: ; show 3rd standard IF from table
038B   300C           02408           movlw  EEPROM_ADR_STD_IF_TABLE + 4*2
038C   2B91           02409           goto   PmLoadFreq2
038D                  02410 PmDisp_IF_4: ; show 4th standard IF from table
038D   3010           02411           movlw  EEPROM_ADR_STD_IF_TABLE + 4*3
038E   2B91           02412           goto   PmLoadFreq2
038F                  02413 PmDisp_IF_5: ; show 5th standard IF from table
038F   3014           02414           movlw  EEPROM_ADR_STD_IF_TABLE + 4*4
0390   2B91           02415           goto   PmLoadFreq2
0391                  02416 PmLoadFreq2: ; Load <freq2> from EEPROM[w] and show it on the display
0391   00AF           02417           movwf  bTemp
0392   3034           02418           movlw  freq2          ; load the ADDRESS of 'freq2' ...
0393   0084           02419           movwf  FSR            ; ... into the PIC's "pointer" register
0394   082F           02420           movfw  bTemp          ; and the EEPROM-internal offset into W
0395   20BA           02421           call  EEPROM_Read4Byte  ; read <freq2> from EEPROM : *FSR = EEPROM[W]
0396   3034           02422           movlw  freq2          ; load the ADDRESS of 'freq2' again ...
0397   0084           02423           movwf  FSR            ; ... into the PIC's "pointer" register
0398   2136           02424           call   ShowInt32_FSR    ; Splitt <*FSR> (32 bit integer) to 8 BCD-digits...
0399   2B3E           02425           goto   ProgModeDisplay  ; and show it for 0.1 seconds, maybe more
                      02426 
                      02427 
                      02428 ; "Execution" of the selectable menu items. Invoked after long key press.
039A                  02429 PmExec_Quit:  ; quit programming mode (without changing anything)
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 56


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

039A   2A4E           02430           goto   MainRestart
                      02431 
039B                  02432 PmExec_PSave: ; turn power-saving mode on/off
039B   3001           02433           movlw  0x01           ; bit0 = power-save
039C   06D5           02434           xorwf  options,f      ; toggle Power-save flag in sofware-"options" register
039D   3055           02435           movlw  options        ; load the ADDRESS of 'options' ...
039E   0084           02436           movwf  FSR            ; ... into the PIC's "pointer" register
039F   3020           02437           movlw  EEPROM_ADR_OPTIONS ; load the EEPROM-internal address offset (=destination)
03A0   209D           02438           call   SaveInEEPROM   ; write *FSR into EEPROM[w]     (bits 31..24)
03A1   2B3E           02439           goto   ProgModeDisplay
                      02440 
03A2                  02441 PmExec_Add:  ; add frequency offset from now on .
                      02442              ; This is achieved by saving the currently measured frequency
                      02443              ; in EEPROM memory and restarting the counter.
03A2                  02444 SaveFreq2:   ; save <freq2> (4 bytes) in the PIC's EEPROM memory :
03A2   3034           02445           movlw  freq2          ; load the ADDRESS of 'freq2' ...
03A3   0084           02446           movwf  FSR            ; ... into the PIC's "pointer" register
03A4   3000           02447           movlw  EEPROM_ADR_FREQ_OFFSET ; load the EEPROM-internal address offset (=destination)
03A5   209D           02448           call   SaveInEEPROM   ; write *FSR into EEPROM[w]     (bits 31..24)
03A6   0A84           02449           incf   FSR, f         ; next source address please
03A7   3001           02450           movlw  EEPROM_ADR_FREQ_OFFSET+1 ; next destination address
03A8   209D           02451           call   SaveInEEPROM   ; write *FSR into EEPROM[w]     (bits 23..16)
03A9   0A84           02452           incf   FSR, f         ; next source address please
03AA   3002           02453           movlw  EEPROM_ADR_FREQ_OFFSET+2 ; next destination address
03AB   209D           02454           call   SaveInEEPROM   ; write *FSR into EEPROM[w]     (bits 15..8)
03AC   0A84           02455           incf   FSR, f         ; next source address please
03AD   3003           02456           movlw  EEPROM_ADR_FREQ_OFFSET+3 ; next destination address
03AE   209D           02457           call   SaveInEEPROM   ; write *FSR into EEPROM[w]     (bits 7..0)
03AF   2A4E           02458           goto   MainRestart    ; restart with new frequency offset
                      02459 
03B0                  02460 PmExec_Sub: ; subtract frequency offset from now on
                      02461             ; This is achieved by making 'freq2' negative (two's complement)
                      02462             ; and then saving it in EEPROM.
                      02463           neg32  freq2          ; freq2 := -freq2  (32 bit)
  0000                    M        local neg_done
03B0   09B4               M            comf  freq2,   f          ; invert all 8 bits in high byte  
03B1   09B5               M            comf  freq2+1, f          ; invert all 8 bits in middle high byte  
03B2   09B6               M            comf  freq2+2, f          ; invert all 8 bits in middle low byte  
03B3   09B7               M            comf  freq2+3, f          ; invert all 8 bits in low byte  
                          M            ; Note at this point 0x000000 would have turned into 0xFFFFFFF .
                          M            ; Must add ONE to complete the TWO's COMPLIMENT calculation ( -0  = 0 ).
                          M            ; Note that "incf" affects only the Z flag but not the C flag .
03B4   0FB7               M            incfsz freq2+3, f         ; increment low byte        (bits 7...0)
03B5   2BBC               M            goto   neg_done           ; if incremented result NOT zero, we're through !
03B6   0FB6               M            incfsz freq2+2, f         ; increment middle low byte (bits 15...8)
03B7   2BBC               M            goto   neg_done           ; if incremented result NOT zero, ...
03B8   0FB5               M            incfsz freq2+1, f         ; increment middle high byte (bits 23...16)
03B9   2BBC               M            goto   neg_done           ; if ...
03BA   0FB4               M            incfsz freq2+0, f         ; increment high byte       (bits 31...24)
03BB   2BBC               M            goto   neg_done           ;
03BC                      M neg_done
03BC   2BA2           02464           goto   SaveFreq2      ; save freq2 in EEPROM and restart
                      02465 
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 57


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

03BD                  02466 PmExec_Zero: ; set frequency offset to zero
03BD   01B4           02467           clrf   freq2_hi       ; freq2 := 0       (32 bit)
03BE   01B5           02468           clrf   freq2_mh       ; ... medium high byte
03BF   01B6           02469           clrf   freq2_ml       ; ... medium low byte
03C0   01B7           02470           clrf   freq2_lo       ; ... low byte
03C1   2BA2           02471           goto   SaveFreq2      ; save freq2 in EEPROM and restart
03C2                  02472 PmExec_StIF   ; switch to  "Standard IF selection mode"
03C2   3006           02473           movlw  MI_IF_1
03C3   00BC           02474 PmExec_SetMI: movwf  menu_index
03C4   2BD5           02475           goto   ProgLoop       ;
                      02476 
03C5                  02477 PmExec_SelIF  ; Finished selecting a "standard IF" from table.
                      02478               ; Switch back to the main menu, and let 
                      02479               ; the user decide if the offset is positive (add) 
                      02480               ; or negative (sub).
03C5   3002           02481           movlw  MI_ADD         ; Suggestion: ADD the offset
03C6   2BC3           02482           goto   PmExec_SetMI
                      02483 
                      02484 
03C7                  02485 EnterProgLoop:
                      02486        ; Prepare 'program mode' : 
03C7   01BC           02487           clrf   menu_index
                      02488 
                      02489        ; Show "Prog" on the display
03C8   3015           02490           movlw  CHAR_P
03C9   2083           02491           call   conv_char0
03CA   3016           02492           movlw  CHAR_r
03CB   2086           02493           call   conv_char1      ; show "Prog" on the display..
03CC   3017           02494           movlw  CHAR_o
03CD   2089           02495           call   conv_char2
03CE   3010           02496           movlw  CHAR_G
03CF   208C           02497           call   conv_char3
03D0   3013           02498           movlw  BLANK           ; Note that the 5th digit is OPTIONAL so we don't use it here
03D1   208F           02499           call   conv_char4
                      02500           ; wait until the operator releases the "Prog" key, while display runs
03D2   233E           02501 Enter2:   call   ProgModeDisplay ; update mux display + provide some delay
03D3   1E85           02502           btfss  IOP_PROG_MODE   ; Button "program mode" still pressed ?
03D4   2BD2           02503           goto   Enter2          ; yes, continue loop while displaying "Prog"
                      02504 
                      02505 
03D5                  02506 ProgLoop:
03D5   0AD1           02507           incf  blinker, f       ; Toggle the blink flag (for flashing for kHz-point)
                      02508        ; Show "quit", "add", "sub", "zero", ... on the display depending on menu_index (0..3)
03D6   204D           02509           call   PMDisplay       ; show  string[menu_index] on LED display (from table)
03D7   1A85           02510           btfsc  IOP_PROG_MODE   ; "program key" pressed now ? (low means pressed)
03D8   2BD5           02511           goto   ProgLoop        ; no, wait until user presses it
                      02512        ; Arrived here, the key is PRESSED. The question is how long...
                      02513        ;  A short press means "advance to the next menu index" ,
                      02514        ;  a longer press means "execute the selected function" .
                      02515        ; Everything under 1 second is considered a "short press".
03D9   300A           02516           movlw  .10             ; 10 * 0.1 sec
03DA   00BD           02517           movwf  menu_timer
03DB   1A85           02518 ChkKey:   btfsc  IOP_PROG_MODE   ; "program key" still pressed ? (low means pressed)
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 58


LOC  OBJECT CODE     LINE SOURCE TEXT
  VALUE

03DC   2BE6           02519           goto   ShortPress      ; no, key released, it was a SHORT press (less than 0.5 seconds)
03DD   233E           02520           call   ProgModeDisplay ; wait another 100 milliseconds
03DE   0BBD           02521           decfsz menu_timer, f   ; decrement timer and skip next instruction if NOT zero 
03DF   2BDB           02522           goto   ChkKey          ; 
                      02523         ; Arrived here, it's a LONG key press, but the key is still down..
                      02524         ; Wait until the operator releases the "Prog" key 
                      02525         ;  Show a BLINKING display while the button is pressed,
                      02526         ;  as an indicator for the user to release the button now.
03E0   2096           02527 Release2: call   ClearDisplay    ; fill display latch with blanking pattern
03E1   233E           02528           call   ProgModeDisplay ; show blank display for 0.1 seconds
03E2   204D           02529           call   PMDisplay       ; show string[menu_index] for 0.1 seconds
03E3   1E85           02530           btfss  IOP_PROG_MODE   ; Button "program mode" still pressed ?
03E4   2BE0           02531           goto   Release2        ; yes, wait for button release, otherwise..  
03E5   285B           02532           goto   PMExecute       ; Execute the function belonging to menu_index
                      02533 
03E6                  02534 ShortPress:  ; advance to the next menu index, but don't execute the associated function
03E6   083C           02535           movfw  menu_index
03E7   3C05           02536           sublw  MI_INDEX_MAX    ; subtract #MI_INDEX_MAX - W register -> C=0 if result negative ("W too
                             large")
03E8   1903           02537           btfsc  STATUS,Z        ; skip next instruction if Z=0
03E9   2BEE           02538           goto   LastMainMenu    ; Z=1 means "this is the last item in the main menu"
03EA   1C03           02539           btfss  STATUS,C        ; skip next instruction if C=1
03EB   2BF0           02540           goto   NotMainMenu     ; C=0 means "this is not the main menu"
03EC   0ABC           02541           incf   menu_index, f   ; menu_index := menu_index+1
03ED   2BD5           02542           goto   ProgLoop  ; end of programming loop
03EE                  02543 LastMainMenu:
03EE   01BC           02544           clrf   menu_index      ; wrap to 1st menu index
03EF   2BD5           02545           goto   ProgLoop  
03F0                  02546 NotMainMenu:   ; not main menu, but sub-menu ..
03F0   083C           02547           movfw  menu_index
03F1   3C0A           02548           sublw  MI_IF_SUBMENU_MAX ; subtract #MI_.. - W register -> C=0 if result negative ("W too larg
                            e")
03F2   1903           02549           btfsc  STATUS,Z        ; skip next instruction if Z=0
03F3   2BF8           02550           goto   LastIfSubMenu   ; Z=1 means "this is the last item in the main menu"
03F4   1C03           02551           btfss  STATUS,C        ; skip next instruction if C=1
03F5   2BFB           02552           goto   NotIfSubMenu    ; C=0 means "this is not the main menu"
03F6   0ABC           02553           incf   menu_index, f   ; menu_index := menu_index+1  (in submenu)
03F7   2BD5           02554           goto   ProgLoop        ;
03F8                  02555 LastIfSubMenu:  ; was in the last "standard IF submenu"..
03F8   3006           02556           movlw  MI_IF_1         ; back to the 1st standard IF submenu
03F9   00BC           02557           movwf  menu_index
03FA   2BD5           02558           goto   ProgLoop  
03FB                  02559 NotIfSubMenu:   ; was not in the "standard IF submenu"..
03FB   01BC           02560           clrf   menu_index      ; must be an error; back to main menu
03FC   2BD5           02561           goto   ProgLoop  
                      02562 
                      02563 
                      02564   END   ; directive 'end of program'
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 59


SYMBOL TABLE
  LABEL                             VALUE 

ADDEN                             00000003
ADEN                              00000003
Adjust                            000002E3
BAUD_DIVIDER                      d'8'
BIT_DELAY                         d'165'
BLANK                             00000013
BLANK_PATTERN                     00000000
BRGH                              00000002
C                                 00000000
C1INV                             00000004
C1OUT                             00000006
C2INV                             00000005
C2OUT                             00000007
CCP1CON                           00000017
CCP1IE                            00000002
CCP1IF                            00000002
CCP1M0                            00000000
CCP1M1                            00000001
CCP1M2                            00000002
CCP1M3                            00000003
CCP1X                             00000005
CCP1Y                             00000004
CCPR1                             00000015
CCPR1H                            00000016
CCPR1L                            00000015
CHAR_A                            0000000A
CHAR_E                            0000000E
CHAR_EQ                           00000023
CHAR_F                            0000000F
CHAR_G                            00000010
CHAR_H                            00000011
CHAR_I                            0000001D
CHAR_J                            0000001E
CHAR_L                            00000020
CHAR_N                            00000021
CHAR_P                            00000015
CHAR_Q                            00000018
CHAR_S                            0000001B
CHAR_V                            00000022
CHAR_Z                            0000001C
CHAR_b                            0000000B
CHAR_c                            0000000C
CHAR_d                            0000000D
CHAR_i                            00000012
CHAR_k                            0000001F
CHAR_o                            00000017
CHAR_r                            00000016
CHAR_t                            0000001A
CHAR_u                            00000019
CIS                               00000003
CLOCK                             01312D00
CM0                               00000000
CM1                               00000001
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 60


SYMBOL TABLE
  LABEL                             VALUE 

CM2                               00000002
CMCON                             0000001F
CMIE                              00000006
CMIF                              00000006
COMMON_ANODE                      0
COMMON_CATHODE                    1
CREN                              00000004
CSRC                              00000007
CYCLES                            00000190
CheckProgMode                     00000324
ChkKey                            000003DB
ClearDisplay                      00000096
CvtAndDisplayFreq                 00000142
DATA_CP_OFF                       00003FFF
DATA_CP_ON                        00003EFF
DC                                00000001
DEBUG                             0
DISPLAY_VARIANT_2                 
DISP_VARIANT                      2
DPPOINT_BIT                       00000001
Digit2MuxValue                    00000026
Digit2SevenSeg                    00000001
EEADR                             0000009B
EECON1                            0000009C
EECON2                            0000009D
EEDATA                            0000009A
EEIE                              00000007
EEIF                              00000007
EEPROM_ADR_FREQ_OFFSET            0x00
EEPROM_ADR_OPTIONS                0x20
EEPROM_ADR_STD_IF_TABLE           0x04
EEPROM_Read4Byte                  000000BA
EEPROM_ReadByte                   000000B0
ENABLE_PORT                       00000005
Enter2                            000003D2
EnterProgLoop                     000003C7
F                                 00000001
FERR                              00000002
FSR                               00000004
GATE_TIME_LOOPS                   0000C350
GIE                               00000007
GoMeasure                         000002AF
INDF                              00000000
INTCON                            0000000B
INTE                              00000004
INTEDG                            00000006
INTF                              00000001
IOP_PROG_MODE                     PORTA,5
IRP                               00000007
KILOHERTZ_FLAG                    1
LAMPTEST_LOOPS                    000061A8
LEDS_PORT                         00000006
LastIfSubMenu                     000003F8
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 61


SYMBOL TABLE
  LABEL                             VALUE 

LastMainMenu                      000003EE
MI_ADD                            00000002
MI_IF_1                           00000006
MI_IF_2                           00000007
MI_IF_3                           00000008
MI_IF_4                           00000009
MI_IF_5                           0000000A
MI_IF_QT                          0000000B
MI_IF_SUBMENU_MAX                 0000000A
MI_INDEX_MAX                      00000005
MI_PSAVE                          00000001
MI_QUIT                           00000000
MI_STD_IF                         00000005
MI_SUB                            00000003
MI_ZERO                           00000004
MainInit                          0000022F
MainLoop                          00000259
MainRestart                       0000024E
NON_INVERTING_RS232_OUT           
NOT_BO                            00000000
NOT_BOD                           00000000
NOT_BOR                           00000000
NOT_PD                            00000003
NOT_POR                           00000001
NOT_RBPU                          00000007
NOT_T1SYNC                        00000002
NOT_TO                            00000004
NO_INPUT_FLAG                     2
NoAdjust                          000002EA
NotIfSubMenu                      000003FB
NotMainMenu                       000003F0
OERR                              00000001
OPTION_REG                        00000081
OPT_PWRSAVE                       options,0
OSCF                              00000003
PCL                               00000002
PCLATH                            0000000A
PCON                              0000008E
PEIE                              00000006
PIE1                              0000008C
PIR1                              0000000C
PMD_NoPwSave                      0000035A
PMDisplay                         0000004D
PMExecute                         0000005B
PORTA                             00000005
PORTB                             00000006
PORT_A_IO                         00000000
PORT_B_IO                         00000000
PR2                               00000092
PROGMODE_LOOPS                    00001388
PS0                               00000000
PS1                               00000001
PS2                               00000002
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 62


SYMBOL TABLE
  LABEL                             VALUE 

PSA                               00000003
PSAVE_DELAY_TIME                  0000003C
PSAVE_FLASHUP_TIME                0000000E
PSAVE_MAX_DIFF                    0000000A
PSC_DIV_BY_128                    00000026
PSC_DIV_BY_16                     00000023
PSC_DIV_BY_2                      00000020
PSC_DIV_BY_256                    00000027
PSC_DIV_BY_32                     00000024
PSC_DIV_BY_4                      00000021
PSC_DIV_BY_64                     00000025
PSC_DIV_BY_8                      00000022
PSFLAG_ACTIVE                     psave_flags,0
PmDisp4                           0000034A
PmDisp5                           0000034C
PmDisp_Add                        00000364
PmDisp_IF_1                       00000387
PmDisp_IF_2                       00000389
PmDisp_IF_3                       0000038B
PmDisp_IF_4                       0000038D
PmDisp_IF_5                       0000038F
PmDisp_PSave                      0000034E
PmDisp_Quit                       00000343
PmDisp_StIF                       0000037C
PmDisp_Sub                        0000036C
PmDisp_Zero                       00000374
PmExec_Add                        000003A2
PmExec_PSave                      0000039B
PmExec_Quit                       0000039A
PmExec_SelIF                      000003C5
PmExec_SetMI                      000003C3
PmExec_StIF                       000003C2
PmExec_Sub                        000003B0
PmExec_Zero                       000003BD
PmLoadFreq2                       00000391
PrepDisp                          000002E0
PrescalerOff                      0000006D
ProgLoop                          000003D5
ProgModeDisplay                   0000033E
PsActive                          000002D1
PsDiffPos                         000002BC
PsFlashUp                         000002D5
PsLargeDiff                       000002C0
PsNoTimeout                       000002DA
PsNotBlanked                      000002E0
PsSleep                           000002DC
PsSmallDiff                       000002C5
RA0                               00000000
RA1                               00000001
RA2                               00000002
RA3                               00000003
RA4                               00000004
RA5                               00000005
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 63


SYMBOL TABLE
  LABEL                             VALUE 

RA6                               00000006
RA7                               00000007
RANGE_DET_LOOPS                   00000682
RB0                               00000000
RB1                               00000001
RB2                               00000002
RB3                               00000003
RB4                               00000004
RB5                               00000005
RB6                               00000006
RB7                               00000007
RBIE                              00000003
RBIF                              00000000
RCIE                              00000005
RCIF                              00000005
RCREG                             0000001A
RCSTA                             00000018
RD                                00000000
RP0                               00000005
RP1                               00000006
RS232_BIT                         D'2'
RS232_OUT                         
RS232_PORT                        PORTB
RS232_PRINT_FIELD_1               
RS232_PRINT_FIELD_2               
RX9                               00000006
RX9D                              00000000
Range1                            0000028A
Range2                            00000294
Range3                            0000029C
Range4                            0000029F
Range5                            000002A3
Range6                            000002A7
Range7                            000002AB
Release2                          000003E0
SPBRG                             00000099
SPEN                              00000007
SREN                              00000005
SSEG_XORMASK                      0x00
STATUS                            00000003
SYNC                              00000004
SaveEW                            000000AB
SaveFreq2                         000003A2
SaveInEEPROM                      0000009D
SetPrescaler                      00000068
ShortPress                        000003E6
ShowInt32_FSR                     00000136
Sleep150ms                        00000077
T0CS                              00000005
T0IE                              00000005
T0IF                              00000002
T0SE                              00000004
T1CKPS0                           00000004
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 64


SYMBOL TABLE
  LABEL                             VALUE 

T1CKPS1                           00000005
T1CON                             00000010
T1OSCEN                           00000003
T2CKPS0                           00000000
T2CKPS1                           00000001
T2CON                             00000012
TEST                              00000014
TIME                              00000014
TMR0                              00000001
TMR0IE                            00000005
TMR0IF                            00000002
TMR1                              0000000E
TMR1CS                            00000001
TMR1H                             0000000F
TMR1IE                            00000000
TMR1IF                            00000000
TMR1L                             0000000E
TMR1ON                            00000000
TMR2                              00000011
TMR2IE                            00000001
TMR2IF                            00000001
TMR2ON                            00000002
TOUTPS0                           00000003
TOUTPS1                           00000004
TOUTPS2                           00000005
TOUTPS3                           00000006
TRISA                             00000085
TRISA0                            00000000
TRISA1                            00000001
TRISA2                            00000002
TRISA3                            00000003
TRISA4                            00000004
TRISA5                            00000005
TRISA6                            00000006
TRISA7                            00000007
TRISB                             00000086
TRISB0                            00000000
TRISB1                            00000001
TRISB2                            00000002
TRISB3                            00000003
TRISB4                            00000004
TRISB5                            00000005
TRISB6                            00000006
TRISB7                            00000007
TRMT                              00000001
TX9                               00000006
TX9D                              00000000
TXEN                              00000005
TXIE                              00000004
TXIF                              00000004
TXREG                             00000019
TXSTA                             00000098
TensTable                         0000002C
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 65


SYMBOL TABLE
  LABEL                             VALUE 

VR0                               00000000
VR1                               00000001
VR2                               00000002
VR3                               00000003
VRCON                             0000009F
VREN                              00000007
VROE                              00000006
VRR                               00000005
W                                 00000000
WR                                00000001
WREN                              00000002
WRERR                             00000003
WasteT1                           000000F2
Z                                 00000002
ZERO_SUPPRESSION_FLAG             4
_A                                0x40
_B                                0x80
_BODEN_OFF                        00003FBF
_BODEN_ON                         00003FFF
_BOREN_OFF                        00003FBF
_BOREN_ON                         00003FFF
_C                                0x04
_CONFIG                           00002007
_CPD_OFF                          00003FFF
_CPD_ON                           00003EFF
_CP_OFF                           00003FFF
_CP_ON                            00001FFF
_D                                0x01
_DEVID1                           00002006
_DP                               0x02
_E                                0x08
_ER_OSC_CLKOUT                    00003FFF
_ER_OSC_NOCLKOUT                  00003FFE
_EXTCLK_OSC                       00003FEF
_F                                0x10
_FOSC_ECIO                        00003FEF
_FOSC_EXTRCCLK                    00003FFF
_FOSC_EXTRCIO                     00003FFE
_FOSC_HS                          00003FEE
_FOSC_INTOSCCLK                   00003FFD
_FOSC_INTOSCIO                    00003FFC
_FOSC_LP                          00003FEC
_FOSC_XT                          00003FED
_G                                0x20
_HS_OSC                           00003FEE
_IDLOC0                           00002000
_IDLOC1                           00002001
_IDLOC2                           00002002
_IDLOC3                           00002003
_INTOSC_OSC_CLKOUT                00003FFD
_INTOSC_OSC_NOCLKOUT              00003FFC
_INTRC_OSC_CLKOUT                 00003FFD
_INTRC_OSC_NOCLKOUT               00003FFC
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 66


SYMBOL TABLE
  LABEL                             VALUE 

_LP_OSC                           00003FEC
_LVP_OFF                          00003F7F
_LVP_ON                           00003FFF
_MCLRE_OFF                        00003FDF
_MCLRE_ON                         00003FFF
_PWRTE_OFF                        00003FFF
_PWRTE_ON                         00003FF7
_RC_OSC_CLKOUT                    00003FFF
_RC_OSC_NOCLKOUT                  00003FFE
_WDTE_OFF                         00003FFB
_WDTE_ON                          00003FFF
_WDT_OFF                          00003FFB
_WDT_ON                           00003FFF
_XT_OSC                           00003FED
__16F628A                         00000001
__DEBUG                           1
add32                             
addcwf                            
adjust_shifts                     00000050
bTemp                             0000002F
baud_divider                      00000058
baud_divider_loop                 0000012F
bit_count                         00000057
bit_delay                         0000012C
blinker                           00000051
clear_tx                          0000011C
conv                              
conv1                             00000145
conv2                             00000157
conv3                             00000178
conv_char0                        00000083
conv_char1                        00000086
conv_char2                        00000089
conv_char3                        0000008C
conv_char4                        0000008F
count1                            000000CC
count3                            00000108
count_pulses                      000000C4
cquad                             
delay_counter                     00000059
digit_0                           00000040
digit_1                           00000041
digit_2                           00000042
digit_3                           00000043
digit_4                           00000044
digit_5                           00000045
digit_6                           00000046
digit_7                           00000047
digit_8                           00000048
digits                            00000040
disp_index                        0000004E
disp_timer                        0000004F
displ_MHz                         0000021F
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 67


SYMBOL TABLE
  LABEL                             VALUE 

displ_kHz                         0000021C
display                           00000221
display0                          00000049
display1                          0000004A
display2                          0000004B
display3                          0000004C
display4                          0000004D
display_freq                      0000019A
divi                              00000028
divi_hi                           00000028
divi_lo                           0000002B
divi_mh                           00000029
divi_ml                           0000002A
eep_dw                            
f_positive                        00000323
foffs                             00000038
foffs_hi                          00000038
foffs_lo                          0000003B
foffs_mh                          00000039
foffs_ml                          0000003A
freq                              00000030
freq2                             00000034
freq2_hi                          00000034
freq2_lo                          00000037
freq2_mh                          00000035
freq2_ml                          00000036
freq_hi                           00000030
freq_lo                           00000033
freq_mh                           00000031
freq_ml                           00000032
freq_overflow                     00000333
freq_underflow                    00000328
gatecnt_hi                        0000002D
gatecnt_lo                        0000002E
menu_index                        0000003C
menu_timer                        0000003D
neg32                             
options                           00000055
pri_1                             000001FD
pri_10                            000001F4
pri_100                           000001EB
pri_1000                          000001E0
pri_10000                         000001D7
pri_100000                        000001CE
pri_1000000                       000001C3
pri_10000000                      000001BD
pri_a                             000001C9
pri_b                             000001D4
pri_c                             000001DD
pri_d                             000001E6
pri_e                             000001F1
pri_f                             000001FA
pri_space                         00000200
MPASM  5.51                FREQUENCYMETER.ASM   2-4-2015  23:29:00         PAGE 68


SYMBOL TABLE
  LABEL                             VALUE 

print_flags                       0000005A
psave_flags                       00000054
psave_freq_lo                     00000053
psave_timer                       00000052
ready_tx                          00000121
send_next_bit                     00000118
set_tx                            0000011F
sub32                             
subncwf                           
table                             
temp                              0000005B
tens_index                        00000027
timer0_old                        0000002C
tx_digit_in_w                     0000010C
tx_dot                            00000109
tx_reg                            00000056
tx_w                              0000010D
us100_delay_loop                  00000131


MEMORY USAGE MAP ('X' = Used,  '-' = Unused)

0000 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0040 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0080 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
00C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0100 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0140 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0180 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
01C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0200 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0240 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0280 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
02C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0300 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0340 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
0380 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX
03C0 : XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXXXXX XXXXXXXXXXXXX---
2000 : XXXX---X-------- ---------------- ---------------- ----------------
2100 : XXXXXXXXXXXXXXXX XXXXXXXX-------- X--------------- ----------------

All other memory blocks unused.

Program Memory Words Used:  1021
Program Memory Words Free:  1027


Errors   :     0
Warnings :     1 reported,     0 suppressed
Messages :    17 reported,    16 suppressed

